<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>í•œêµ­ì–´/ì˜ì–´ TTS ë¦½ì‹±í¬ - ê·¸ë¦°ìŠ¤í¬ë¦° (ë¬´ìŒ ê°ì§€)</title>
    <style>
        * {
            box-sizing: border-box;
        }

        body {
            margin: 0;
            padding: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen', 'Ubuntu', 'Cantarell', sans-serif;
        }

        .main-container {
            display: flex;
            gap: 30px;
            align-items: flex-start;
            padding: 20px;
            flex-wrap: wrap;
            justify-content: center;
            max-width: 1400px;
            width: 100%;
        }

        .canvas-container {
            background: rgba(42, 42, 42, 0.8);
            padding: 25px;
            border-radius: 20px;
            box-shadow: 0 15px 50px rgba(0,0,0,0.6);
            backdrop-filter: blur(10px);
        }

        #greenscreenCanvas {
            display: block;
            border-radius: 15px;
            box-shadow: 0 8px 30px rgba(0, 255, 0, 0.4);
            border: 3px solid rgba(0, 255, 0, 0.3);
        }

        .canvas-info {
            margin-top: 15px;
            text-align: center;
            color: #00ff88;
            font-size: 15px;
            font-weight: bold;
            text-shadow: 0 0 10px rgba(0, 255, 136, 0.5);
        }

        .controls {
            background: rgba(255, 255, 255, 0.95);
            padding: 35px;
            border-radius: 25px;
            box-shadow: 0 15px 50px rgba(0,0,0,0.4);
            max-width: 500px;
            width: 100%;
        }

        .controls h2 {
            margin: 0 0 25px 0;
            color: #1a1a2e;
            font-size: 28px;
            text-align: center;
            font-weight: 800;
        }

        .section {
            margin-bottom: 25px;
            padding-bottom: 25px;
            border-bottom: 2px solid #f0f0f0;
        }

        .section:last-child {
            border-bottom: none;
            margin-bottom: 0;
        }

        .section h3 {
            margin: 0 0 15px 0;
            color: #333;
            font-size: 18px;
            font-weight: 700;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        textarea {
            width: 100%;
            height: 100px;
            padding: 15px;
            border: 2px solid #e0e0e0;
            border-radius: 12px;
            font-size: 16px;
            resize: vertical;
            font-family: inherit;
            transition: border-color 0.3s;
        }

        textarea:focus {
            outline: none;
            border-color: #00ff88;
            box-shadow: 0 0 0 3px rgba(0, 255, 136, 0.1);
        }

        select, input[type="number"] {
            width: 100%;
            padding: 12px;
            border: 2px solid #e0e0e0;
            border-radius: 12px;
            font-size: 15px;
            margin-bottom: 12px;
            font-family: inherit;
            transition: border-color 0.3s;
        }

        select:focus, input[type="number"]:focus {
            outline: none;
            border-color: #00ff88;
        }

        button {
            background: linear-gradient(135deg, #00ff88 0%, #00cc6a 100%);
            color: white;
            border: none;
            padding: 14px 32px;
            font-size: 16px;
            border-radius: 50px;
            cursor: pointer;
            margin: 6px;
            transition: all 0.3s;
            font-weight: 700;
            width: calc(50% - 12px);
            box-shadow: 0 4px 15px rgba(0, 255, 136, 0.3);
        }

        button:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 6px 25px rgba(0, 255, 136, 0.4);
        }

        button:active:not(:disabled) {
            transform: translateY(0);
        }

        button:disabled {
            background: #cccccc;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        .button-row {
            display: flex;
            flex-wrap: wrap;
            gap: 12px;
        }

        .full-button {
            width: 100% !important;
            margin: 6px 0 !important;
        }

        .recording-btn {
            background: linear-gradient(135deg, #ff4444 0%, #cc0000 100%);
            box-shadow: 0 4px 15px rgba(255, 68, 68, 0.3);
        }

        .recording-btn.recording {
            background: linear-gradient(135deg, #ff6b6b 0%, #ff4444 100%);
            animation: pulse 1.5s ease-in-out infinite;
        }

        @keyframes pulse {
            0%, 100% { box-shadow: 0 4px 15px rgba(255, 68, 68, 0.3); }
            50% { box-shadow: 0 4px 25px rgba(255, 68, 68, 0.6); }
        }

        .download-btn {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.3);
        }

        .status {
            margin-top: 15px;
            padding: 14px;
            border-radius: 12px;
            font-size: 14px;
            text-align: center;
            font-weight: 600;
        }

        .status.speaking {
            background: linear-gradient(135deg, #d4edda 0%, #c3e6cb 100%);
            color: #155724;
        }

        .status.idle {
            background: #f8f9fa;
            color: #6c757d;
        }

        .status.recording {
            background: linear-gradient(135deg, #f8d7da 0%, #f5c6cb 100%);
            color: #721c24;
        }

        .info {
            padding: 15px;
            background: linear-gradient(135deg, #e7f3ff 0%, #dae9f7 100%);
            border-radius: 12px;
            font-size: 13px;
            color: #004085;
            line-height: 1.8;
            border-left: 4px solid #0066cc;
        }

        .info strong {
            color: #003366;
        }

        .color-picker {
            display: flex;
            align-items: center;
            gap: 12px;
            flex-wrap: wrap;
        }

        .color-picker label {
            font-size: 15px;
            color: #555;
            font-weight: 600;
        }

        .color-picker input[type="color"] {
            width: 70px;
            height: 40px;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            cursor: pointer;
        }

        .slider-container {
            margin: 12px 0;
        }

        .slider-container label {
            display: block;
            font-size: 14px;
            color: #555;
            margin-bottom: 8px;
            font-weight: 600;
        }

        input[type="range"] {
            width: 100%;
            height: 6px;
            border-radius: 3px;
            background: #e0e0e0;
            outline: none;
            -webkit-appearance: none;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #00ff88;
            cursor: pointer;
            box-shadow: 0 2px 8px rgba(0, 255, 136, 0.4);
        }

        input[type="range"]::-moz-range-thumb {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #00ff88;
            cursor: pointer;
            border: none;
            box-shadow: 0 2px 8px rgba(0, 255, 136, 0.4);
        }

        .file-upload {
            margin-top: 12px;
        }

        .file-upload input[type="file"] {
            width: 100%;
            padding: 12px;
            border: 2px dashed #00ff88;
            border-radius: 12px;
            font-size: 14px;
            cursor: pointer;
            background: rgba(0, 255, 136, 0.05);
            transition: all 0.3s;
        }

        .file-upload input[type="file"]:hover {
            background: rgba(0, 255, 136, 0.1);
            border-color: #00cc6a;
        }

        .grid-settings {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 12px;
            margin-top: 12px;
        }

        .grid-settings label {
            font-size: 14px;
            color: #555;
            font-weight: 600;
        }

        .grid-settings input {
            margin-top: 6px;
        }

        .preview-grid {
            display: grid;
            gap: 8px;
            margin-top: 15px;
            padding: 15px;
            background: #f8f8f8;
            border-radius: 12px;
            max-height: 280px;
            overflow-y: auto;
            border: 2px solid #e0e0e0;
        }

        .preview-grid::-webkit-scrollbar {
            width: 8px;
        }

        .preview-grid::-webkit-scrollbar-track {
            background: #f1f1f1;
            border-radius: 4px;
        }

        .preview-grid::-webkit-scrollbar-thumb {
            background: #00ff88;
            border-radius: 4px;
        }

        .preview-mouth {
            width: 100%;
            aspect-ratio: 1;
            object-fit: contain;
            border: 3px solid transparent;
            border-radius: 8px;
            cursor: pointer;
            background: white;
            position: relative;
            transition: all 0.2s;
        }

        .preview-mouth:hover {
            border-color: #00ff88;
            transform: scale(1.05);
        }

        .preview-mouth.selected {
            border-color: #00ff88;
            box-shadow: 0 0 15px rgba(0, 255, 136, 0.6);
        }

        .mouth-label {
            position: absolute;
            bottom: 4px;
            right: 4px;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 3px 8px;
            border-radius: 4px;
            font-size: 11px;
            font-weight: bold;
        }

        .phoneme-mapping {
            background: #f9f9f9;
            padding: 15px;
            border-radius: 12px;
            margin-top: 12px;
            border: 2px solid #e0e0e0;
        }

        .phoneme-mapping h4 {
            margin: 0 0 12px 0;
            font-size: 15px;
            color: #333;
            font-weight: 700;
        }

        .phoneme-item {
            display: flex;
            align-items: center;
            margin: 8px 0;
            gap: 12px;
        }

        .phoneme-item select {
            flex: 1;
            padding: 8px;
            font-size: 13px;
            margin: 0;
        }

        .phoneme-item label {
            min-width: 100px;
            font-weight: 600;
            color: #555;
            font-size: 13px;
        }

        .preset-btn {
            width: auto !important;
            padding: 10px 20px !important;
            font-size: 14px !important;
        }

        .speed-control {
            display: flex;
            gap: 8px;
            margin-top: 12px;
        }

        .speed-btn {
            flex: 1;
            padding: 8px !important;
            font-size: 13px !important;
            width: auto !important;
            margin: 0 !important;
        }

        .speed-btn.active {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        }

        .lang-toggle {
            display: flex;
            gap: 8px;
            margin-bottom: 12px;
        }

        .lang-btn {
            flex: 1;
            padding: 10px !important;
            font-size: 14px !important;
            width: auto !important;
            margin: 0 !important;
        }

        .lang-btn.active {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        }
    </style>
</head>
<body>
    <div class="main-container">
        <div class="canvas-container">
            <canvas id="greenscreenCanvas" width="800" height="600"></canvas>
            <div class="canvas-info">ğŸ¬ ì¤€ë¹„ ì™„ë£Œ</div>
        </div>

        <div class="controls">
            <h2>ğŸ¤ í•œêµ­ì–´/ì˜ì–´ TTS ë¦½ì‹±í¬</h2>

            <div class="section">
                <h3>ğŸ–¼ï¸ ì… ëª¨ì–‘ ì´ë¯¸ì§€</h3>
                <div class="file-upload">
                    <input type="file" id="mouthImageUpload" accept="image/*" onchange="loadMouthImage(event)">
                </div>
                <div class="grid-settings">
                    <label>
                        ì—´ (ê°€ë¡œ):
                        <input type="number" id="gridCols" min="1" max="10" value="4" onchange="updateGrid()">
                    </label>
                    <label>
                        í–‰ (ì„¸ë¡œ):
                        <input type="number" id="gridRows" min="1" max="10" value="5" onchange="updateGrid()">
                    </label>
                </div>
                <div id="previewGrid" class="preview-grid" style="display:none;"></div>
            </div>

            <div class="section" id="phonemeMappingSection" style="display:none;">
                <h3>ğŸ—£ï¸ ë°œìŒ ë§¤í•‘</h3>
                <div class="lang-toggle">
                    <button class="lang-btn active" onclick="switchLanguage('korean')">ğŸ‡°ğŸ‡· í•œêµ­ì–´</button>
                    <button class="lang-btn" onclick="switchLanguage('english')">ğŸ‡ºğŸ‡¸ ì˜ì–´</button>
                </div>
                <div class="phoneme-mapping" id="phonemeMappingKorean"></div>
                <div class="phoneme-mapping" id="phonemeMappingEnglish" style="display:none;"></div>
            </div>

            <div class="section">
                <h3>ğŸµ ì˜¤ë””ì˜¤ ì†ŒìŠ¤</h3>
                <div class="lang-toggle">
                    <button class="lang-btn active" onclick="switchAudioMode('tts')">ğŸ—£ï¸ TTS ìŒì„±</button>
                    <button class="lang-btn" onclick="switchAudioMode('upload')">ğŸ“ ì˜¤ë””ì˜¤ ì—…ë¡œë“œ</button>
                </div>
                
                <div id="ttsMode">
                    <div style="margin-top: 15px;">
                        <h4 style="margin: 0 0 10px 0; font-size: 15px; color: #555;">ğŸ’¬ ëŒ€ì‚¬</h4>
                        <textarea id="textInput" placeholder="í•œêµ­ì–´ë‚˜ ì˜ì–´ í…ìŠ¤íŠ¸ë¥¼ ì…ë ¥í•˜ì„¸ìš”...">ì•ˆë…•í•˜ì„¸ìš”! Hello World! í•œêµ­ì–´ì™€ ì˜ì–´ë¥¼ ìë™ìœ¼ë¡œ ì¸ì‹í•©ë‹ˆë‹¤.</textarea>
                    </div>
                    
                    <div style="margin-top: 15px;">
                        <h4 style="margin: 0 0 10px 0; font-size: 15px; color: #555;">ğŸ™ï¸ TTS ì—”ì§„</h4>
                        <div class="lang-toggle">
                            <button class="lang-btn active" onclick="switchTTSEngine('browser')">ğŸŒ ë¸Œë¼ìš°ì € TTS</button>
                            <button class="lang-btn" onclick="switchTTSEngine('google')">ğŸ‡¬ Google Cloud</button>
                        </div>
                    </div>
                    
                    <div id="browserTTSSettings">
                        <div style="margin-top: 15px;">
                            <h4 style="margin: 0 0 10px 0; font-size: 15px; color: #555;">ğŸ”Š ìŒì„±</h4>
                            <select id="voiceSelect">
                                <option value="">ìŒì„± ë¡œë”© ì¤‘...</option>
                            </select>
                            <button onclick="loadVoices(); alert('ìŒì„± ëª©ë¡ì„ ìƒˆë¡œê³ ì¹¨í–ˆìŠµë‹ˆë‹¤!');" class="full-button" style="background: linear-gradient(135deg, #ffa500 0%, #ff8c00 100%); padding: 10px; font-size: 14px; margin-top: 8px;">ğŸ”„ ìŒì„± ìƒˆë¡œê³ ì¹¨</button>
                        </div>
                    </div>
                    
                    <div id="googleTTSSettings" style="display: none;">
                        <div style="margin-top: 15px; padding: 10px; background: #f0f9ff; border-radius: 8px; border-left: 3px solid #0891b2;">
                            <label style="display: block; font-size: 13px; font-weight: 600; color: #0e7490; margin-bottom: 6px;">
                                ğŸ”‘ Google Cloud TTS API Key
                            </label>
                            <input type="password" id="googleTTSApiKey" placeholder="AIzaSy..." style="width: 100%; padding: 8px; border: 1px solid #bae6fd; border-radius: 6px; font-size: 13px;">
                            <div style="font-size: 11px; color: #0369a1; margin-top: 4px;">
                                ê³ í’ˆì§ˆ í•œêµ­ì–´ TTS ì§€ì›. ë¬´ë£Œ í• ë‹¹ëŸ‰: ì›” 400ë§Œì
                            </div>
                        </div>
                        
                        <div style="margin-top: 15px;">
                            <h4 style="margin: 0 0 10px 0; font-size: 15px; color: #555;">ğŸ”Š í•œêµ­ì–´ ìŒì„±</h4>
                            <select id="googleVoiceSelect" style="width: 100%; padding: 10px; border-radius: 8px;">
                                <option value="ko-KR-Standard-A">ko-KR-Standard-A (ì—¬ì„±)</option>
                                <option value="ko-KR-Standard-B">ko-KR-Standard-B (ì—¬ì„±)</option>
                                <option value="ko-KR-Standard-C">ko-KR-Standard-C (ë‚¨ì„±)</option>
                                <option value="ko-KR-Standard-D">ko-KR-Standard-D (ë‚¨ì„±)</option>
                                <option value="ko-KR-Wavenet-A">ko-KR-Wavenet-A (ì—¬ì„±, ê³ í’ˆì§ˆ) â­</option>
                                <option value="ko-KR-Wavenet-B">ko-KR-Wavenet-B (ì—¬ì„±, ê³ í’ˆì§ˆ) â­</option>
                                <option value="ko-KR-Wavenet-C">ko-KR-Wavenet-C (ë‚¨ì„±, ê³ í’ˆì§ˆ) â­</option>
                                <option value="ko-KR-Wavenet-D">ko-KR-Wavenet-D (ë‚¨ì„±, ê³ í’ˆì§ˆ) â­</option>
                                <option value="ko-KR-Neural2-A">ko-KR-Neural2-A (ì—¬ì„±, ìµœê³ í’ˆì§ˆ) ğŸŒŸ</option>
                                <option value="ko-KR-Neural2-B">ko-KR-Neural2-B (ì—¬ì„±, ìµœê³ í’ˆì§ˆ) ğŸŒŸ</option>
                                <option value="ko-KR-Neural2-C">ko-KR-Neural2-C (ë‚¨ì„±, ìµœê³ í’ˆì§ˆ) ğŸŒŸ</option>
                            </select>
                        </div>
                    </div>
                </div>
                
                <div id="uploadMode" style="display: none;">
                    <div style="margin-top: 15px;">
                        <h4 style="margin: 0 0 10px 0; font-size: 15px; color: #555;">ğŸµ ì˜¤ë””ì˜¤ íŒŒì¼</h4>
                        <div class="file-upload">
                            <input type="file" id="audioUpload" accept="audio/*" onchange="loadAudioFile(event)">
                        </div>
                        <div id="audioInfo" style="margin-top: 10px; padding: 10px; background: #f0f0f0; border-radius: 8px; font-size: 13px; display: none;">
                            <strong>íŒŒì¼:</strong> <span id="audioFileName">-</span><br>
                            <strong>ê¸¸ì´:</strong> <span id="audioDuration">-</span>ì´ˆ
                        </div>
                    </div>
                    
                    <div style="margin-top: 15px;">
                        <h4 style="margin: 0 0 10px 0; font-size: 15px; color: #555;">ğŸ’¬ ëŒ€ì‚¬ (ë¦½ì‹±í¬ìš©)</h4>
                        <textarea id="textInputUpload" placeholder="ë¦½ì‹±í¬ë¥¼ ìœ„í•œ í…ìŠ¤íŠ¸ë¥¼ ì…ë ¥í•˜ì„¸ìš”..."></textarea>
                        
                        <div style="margin-top: 12px; padding: 10px; background: #f0f9ff; border-radius: 8px; border-left: 3px solid #0891b2;">
                            <label style="display: block; font-size: 13px; font-weight: 600; color: #0e7490; margin-bottom: 6px;">
                                ğŸ”‘ AssemblyAI API Key (ìŒì„±ì¸ì‹ìš©)
                            </label>
                            <input type="password" id="assemblyApiKey" placeholder="xxxxxxxxxxxxxxxxxxxxxxxx" style="width: 100%; padding: 8px; border: 1px solid #bae6fd; border-radius: 6px; font-size: 13px;">
                            <div style="font-size: 11px; color: #0369a1; margin-top: 4px;">
                                ì„ íƒì‚¬í•­. API í‚¤ ì…ë ¥ ì‹œ AssemblyAIë¡œ ì •í™•í•œ ìŒì„±ì¸ì‹ ê°€ëŠ¥ (ë¬´ë£Œ: 5ì‹œê°„/ì›”)
                            </div>
                        </div>
                        
                        <div style="margin-top: 8px; display: flex; gap: 8px; flex-wrap: wrap;">
                            <button onclick="transcribeWithAssembly()" class="preset-btn" style="background: linear-gradient(135deg, #10b981 0%, #059669 100%); flex: 1;">
                                ğŸ¤ AssemblyAI ìŒì„±ì¸ì‹
                            </button>
                            <button onclick="estimateFromAudio()" class="preset-btn" style="background: linear-gradient(135deg, #0891b2 0%, #0e7490 100%); flex: 1;">
                                ğŸ¤– ìŒëŸ‰ ë¶„ì„
                            </button>
                        </div>
                        <div id="transcriptionStatus" style="margin-top: 8px; padding: 8px; background: #e7f3ff; border-radius: 6px; font-size: 12px; display: none;">
                            <span id="transcriptionText">ëŒ€ê¸° ì¤‘...</span>
                        </div>
                        <div style="margin-top: 8px; font-size: 12px; color: #666; line-height: 1.6;">
                            ğŸ¤ <strong>AssemblyAI:</strong> ì •í™•í•œ ìŒì„±ì¸ì‹, ë¬´ë£Œ 5ì‹œê°„/ì›” (API í‚¤ í•„ìš”)<br>
                            ğŸ¤– <strong>ìŒëŸ‰ ë¶„ì„:</strong> ìŒëŸ‰ íŒ¨í„´ìœ¼ë¡œ í…ìŠ¤íŠ¸ ì¶”ì • (API í‚¤ ë¶ˆí•„ìš”)
                        </div>
                    </div>
                </div>
            </div>

            <div class="section">
                <h3>âš™ï¸ ì„¤ì •</h3>
                <div class="speed-control">
                    <button class="speed-btn" onclick="setSpeed(0.8)">ëŠë¦¬ê²Œ</button>
                    <button class="speed-btn active" onclick="setSpeed(1.0)">ë³´í†µ</button>
                    <button class="speed-btn" onclick="setSpeed(1.2)">ë¹ ë¥´ê²Œ</button>
                </div>
            </div>

            <div class="section">
                <h3>ğŸ¨ ë°°ê²½</h3>
                <div class="color-picker">
                    <label>ë°°ê²½ìƒ‰:</label>
                    <input type="color" id="bgColor" value="#00ff00">
                    <button class="preset-btn" onclick="setPresetColor('#00ff00')">ğŸŸ¢ ê·¸ë¦°</button>
                    <button class="preset-btn" onclick="setPresetColor('#0000ff')" style="background: linear-gradient(135deg, #0066ff 0%, #0044cc 100%);">ğŸ”µ ë¸”ë£¨</button>
                </div>
            </div>

            <div class="section">
                <h3>ğŸ“ í¬ê¸°</h3>
                <div class="slider-container">
                    <label>ì… í¬ê¸°: <span id="sizeValue">2.0</span>x</label>
                    <input type="range" id="mouthSize" min="0.5" max="4" step="0.1" value="2.0" oninput="updateMouthSize()">
                </div>
            </div>

            <div class="section">
                <h3>ğŸ”‡ ë¬´ìŒ ê°ì§€</h3>
                <div class="slider-container">
                    <label>ë¯¼ê°ë„: <span id="silenceValue">25</span> (ë‚®ì„ìˆ˜ë¡ ë¯¼ê°)</label>
                    <input type="range" id="silenceThresholdSlider" min="10" max="50" step="5" value="25" oninput="updateSilenceThreshold()">
                </div>
                <div class="info" style="margin-top: 10px; font-size: 12px;">
                    ì˜¤ë””ì˜¤ ì¬ìƒ ì‹œ ë¬´ìŒ êµ¬ê°„ì„ ê°ì§€í•˜ì—¬<br>ìë™ìœ¼ë¡œ ì…ì„ ë‹«ìŠµë‹ˆë‹¤
                </div>
            </div>

            <div class="section">
                <h3>â–¶ï¸ ì¬ìƒ</h3>
                <div class="button-row">
                    <button id="speakBtn" onclick="speak()">ğŸ—£ï¸ ë§í•˜ê¸°</button>
                    <button id="stopBtn" onclick="stop()" disabled>â¹ï¸ ì •ì§€</button>
                </div>
            </div>

            <div class="section">
                <h3>ğŸ¥ ë…¹í™”</h3>
                <button id="recordBtn" class="recording-btn full-button" onclick="toggleRecording()">âºï¸ ë…¹í™” ì‹œì‘</button>
                <button id="downloadBtn" class="download-btn full-button" onclick="downloadVideo()" disabled style="display:none;">ğŸ’¾ ì˜ìƒ ë‹¤ìš´ë¡œë“œ</button>
            </div>

            <div id="status" class="status idle">ì… ëª¨ì–‘ ì´ë¯¸ì§€ë¥¼ ì—…ë¡œë“œí•˜ì„¸ìš”</div>

            <div class="info">
                <strong>ğŸ’¡ ì‚¬ìš© ë°©ë²•:</strong><br>
                1ï¸âƒ£ ì… ëª¨ì–‘ ìŠ¤í”„ë¼ì´íŠ¸ ì‹œíŠ¸ ì—…ë¡œë“œ<br>
                2ï¸âƒ£ ê²©ì í¬ê¸° ì„¤ì • (ìë™ ë¶„í• )<br>
                3ï¸âƒ£ í•œêµ­ì–´/ì˜ì–´ ë°œìŒë³„ ì… ëª¨ì–‘ ë§¤í•‘<br>
                4ï¸âƒ£ <strong>ì˜¤ë””ì˜¤ ì†ŒìŠ¤ ì„ íƒ:</strong><br>
                &nbsp;&nbsp;&nbsp;â€¢ TTS ìŒì„±: í…ìŠ¤íŠ¸ ì…ë ¥ í›„ ìë™ ìŒì„± ìƒì„±<br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- ë¸Œë¼ìš°ì € TTS (ë¬´ë£Œ, í•œêµ­ì–´ ì œí•œì )<br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- Google Cloud TTS (ê³ í’ˆì§ˆ í•œêµ­ì–´) â­<br>
                &nbsp;&nbsp;&nbsp;â€¢ ì˜¤ë””ì˜¤ ì—…ë¡œë“œ: MP3/WAV íŒŒì¼ ì—…ë¡œë“œ<br>
                5ï¸âƒ£ ë§í•˜ê¸° ë²„íŠ¼ í´ë¦­!<br>
                <br>
                <strong>ğŸ™ï¸ Google Cloud TTS (ê¶Œì¥):</strong><br>
                â€¢ <strong>ê³ í’ˆì§ˆ í•œêµ­ì–´ ìŒì„±</strong> - ìì—°ìŠ¤ëŸ¬ìš´ ë°œìŒ<br>
                â€¢ Standard, Wavenet, Neural2 ìŒì„± ì§€ì›<br>
                â€¢ ë¬´ë£Œ í• ë‹¹ëŸ‰: ì›” 400ë§Œì (ì¶©ë¶„í•¨!)<br>
                â€¢ API í‚¤ ë°œê¸‰: https://console.cloud.google.com<br>
                &nbsp;&nbsp;1. Text-to-Speech API í™œì„±í™”<br>
                &nbsp;&nbsp;2. API í‚¤ ìƒì„±<br>
                &nbsp;&nbsp;3. ìœ„ ì…ë ¥ë€ì— ë¶™ì—¬ë„£ê¸°<br>
                <br>
                <strong>ğŸµ ì˜¤ë””ì˜¤ ì—…ë¡œë“œ ëª¨ë“œ:</strong><br>
                â€¢ <strong>AssemblyAI:</strong> ì •í™•í•œ ìŒì„±ì¸ì‹, ë¬´ë£Œ 5ì‹œê°„/ì›” (API í‚¤ í•„ìš”)<br>
                â€¢ <strong>ìŒëŸ‰ ë¶„ì„:</strong> ìŒëŸ‰ íŒ¨í„´ìœ¼ë¡œ í…ìŠ¤íŠ¸ ì¶”ì • (ë¬´ë£Œ)<br>
                â€¢ <strong>ìˆ˜ë™ ì…ë ¥:</strong> ì§ì ‘ í…ìŠ¤íŠ¸ ì…ë ¥ (ê°€ì¥ ì •í™•)<br>
                <br>
                <strong>ğŸ”‡ ë¬´ìŒ ê°ì§€:</strong><br>
                â€¢ ì˜¤ë””ì˜¤ ì¬ìƒ ì¤‘ ì‹¤ì‹œê°„ìœ¼ë¡œ ë¬´ìŒ êµ¬ê°„ ê°ì§€<br>
                â€¢ ë¬´ìŒì¼ ë•Œ ìë™ìœ¼ë¡œ ì…ì„ ë‹«ì•„ ìì—°ìŠ¤ëŸ¬ìš´ ë¦½ì‹±í¬<br>
                â€¢ ë¯¼ê°ë„ ì¡°ì ˆë¡œ ê°ì§€ ì •í™•ë„ ì¡°ì • ê°€ëŠ¥<br>
                <br>
                <strong>ğŸ”‘ AssemblyAI API í‚¤ ë°œê¸‰:</strong><br>
                â€¢ https://www.assemblyai.com/dashboard ì ‘ì†<br>
                â€¢ íšŒì›ê°€ì… (ë¬´ë£Œ)<br>
                â€¢ Dashboardì—ì„œ API Key ë³µì‚¬<br>
                â€¢ ë¬´ë£Œ í”Œëœ: ì›” 5ì‹œê°„ (ì¶©ë¶„í•¨!)<br>
                <br>
                <strong>ğŸŒ ë‹¤êµ­ì–´ ì§€ì›:</strong><br>
                â€¢ í•œêµ­ì–´ì™€ ì˜ì–´ë¥¼ ìë™ìœ¼ë¡œ ê°ì§€<br>
                â€¢ ê° ì–¸ì–´ì— ë§ëŠ” ë¦½ì‹±í¬ ì ìš©<br>
                <br>
                <strong>âŒ¨ï¸ ë‹¨ì¶•í‚¤:</strong> Ctrl+Enter = ë§í•˜ê¸°
            </div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('greenscreenCanvas');
        const ctx = canvas.getContext('2d');
        
        let synth = window.speechSynthesis;
        let utterance = null;
        let voices = [];
        let speechRate = 1.0;
        let mouthScale = 2.0;
        
        let mouthSpriteSheet = null;
        let mouthFrames = [];
        let currentMouthIndex = 0;
        let rows = 5;
        let cols = 4;
        
        let mediaRecorder = null;
        let recordedChunks = [];
        let isRecording = false;
        let isSpeaking = false;
        let animationInterval = null;
        let currentMappingLanguage = 'korean';
        let audioMode = 'tts'; // 'tts' or 'upload'
        let ttsEngine = 'browser'; // 'browser' or 'google'
        let uploadedAudio = null;
        let audioContext = null;
        let audioSource = null; // ì˜¤ë””ì˜¤ ì†ŒìŠ¤ë¥¼ ì¬ì‚¬ìš©í•˜ê¸° ìœ„í•´ ì €ì¥
        
        // ì‹¤ì‹œê°„ ìŒì„± ë¶„ì„ì„ ìœ„í•œ ë³€ìˆ˜ë“¤
        let analyser = null;
        let microphone = null;
        let silenceThreshold = 25; // ë¬´ìŒ íŒì • ê¸°ì¤€ (0-100, ë‚®ì„ìˆ˜ë¡ ë¯¼ê°)
        let lastSoundTime = 0;
        let silenceDelay = 150; // ë¬´ìŒìœ¼ë¡œ íŒì •ë˜ê¸°ê¹Œì§€ì˜ ì§€ì—°ì‹œê°„ (ms)
        let audioMonitorInterval = null;

        // í•œêµ­ì–´ ë°œìŒ ë§¤í•‘
        let phonemeMapKorean = {
            'rest': 0,
            'a': 4,
            'ae': 5,
            'eo': 6,
            'e': 7,
            'o': 8,
            'u': 9,
            'eu': 10,
            'i': 11,
            'b_p_m': 12,
            'n': 13,
            's': 14,
            't_d': 15,
            'g_k': 16,
            'j': 17,
            'h': 18,
            'ng': 19
        };

        // ì˜ì–´ ë°œìŒ ë§¤í•‘ (Viseme based)
        let phonemeMapEnglish = {
            'rest': 0,           // Silence
            'AA': 4,             // f AA ther (í° ì…)
            'AE': 5,             // c AE t (ì•½ê°„ ë²Œë¦°)
            'AH': 6,             // b UH t (ì¤‘ê°„)
            'AO': 8,             // d OG (ë‘¥ê·¼ ì…)
            'AW': 4,             // d OW n (í° ì…)
            'AY': 5,             // h I de (ì•½ê°„ ë²Œë¦°)
            'EH': 7,             // b E d (ì‘ê²Œ ë²Œë¦°)
            'ER': 6,             // h ER (ì¤‘ê°„)
            'EY': 7,             // s AY (ì‘ê²Œ ë²Œë¦°)
            'IH': 11,            // s I t (ì¢ê²Œ)
            'IY': 11,            // s EE (ì´)
            'OW': 8,             // b OA t (ë‘¥ê·¼)
            'OY': 8,             // b OY (ë‘¥ê·¼)
            'UH': 9,             // b OO k (ë‘¥ê·¼ í¬ê²Œ)
            'UW': 9,             // f OO d (ìš°)
            'B': 12,             // B (ì… ë‹¤ë¬¸)
            'P': 12,             // P (ì… ë‹¤ë¬¸)
            'M': 12,             // M (ì… ë‹¤ë¬¸)
            'F': 14,             // F (ì´ ë³´ì„)
            'V': 14,             // V (ì´ ë³´ì„)
            'TH': 14,            // TH (ì´ ë³´ì„)
            'DH': 14,            // THE (ì´ ë³´ì„)
            'S': 14,             // S (ì´ ë³´ì„)
            'Z': 14,             // Z (ì´ ë³´ì„)
            'SH': 17,            // SH (ì…ìˆ  ì•)
            'ZH': 17,            // mea S ure (ì…ìˆ  ì•)
            'CH': 17,            // CH (ì…ìˆ  ì•)
            'JH': 17,            // J (ì…ìˆ  ì•)
            'T': 15,             // T (í˜€ ì•)
            'D': 15,             // D (í˜€ ì•)
            'N': 13,             // N (í˜€ ìœ„ì¹˜)
            'L': 13,             // L (í˜€ ìœ„ì¹˜)
            'R': 6,              // R (ì¤‘ê°„)
            'K': 16,             // K (ëª©)
            'G': 16,             // G (ëª©)
            'NG': 19,            // si NG (ëª©)
            'H': 18,             // H (í¬ê²Œ)
            'W': 9,              // W (ë‘¥ê·¼)
            'Y': 11              // Y (ì¢ê²Œ)
        };

        // í˜„ì¬ ì‚¬ìš©í•  ë§¤í•‘
        let currentPhonemeMap = phonemeMapKorean;

        // í•œêµ­ì–´ ìëª¨ ë¶„í•´
        function decomposeHangul(char) {
            const code = char.charCodeAt(0);
            if (code < 0xAC00 || code > 0xD7A3) return null;
            
            const syllableIndex = code - 0xAC00;
            const jongIndex = syllableIndex % 28;
            const jungIndex = Math.floor((syllableIndex - jongIndex) / 28) % 21;
            const choIndex = Math.floor((syllableIndex - jongIndex) / 28 / 21);
            
            const cho = ['ã„±','ã„²','ã„´','ã„·','ã„¸','ã„¹','ã…','ã…‚','ã…ƒ','ã……','ã…†','ã…‡','ã…ˆ','ã…‰','ã…Š','ã…‹','ã…Œ','ã…','ã…'];
            const jung = ['ã…','ã…','ã…‘','ã…’','ã…“','ã…”','ã…•','ã…–','ã…—','ã…˜','ã…™','ã…š','ã…›','ã…œ','ã…','ã…','ã…Ÿ','ã… ','ã…¡','ã…¢','ã…£'];
            const jong = ['','ã„±','ã„²','ã„³','ã„´','ã„µ','ã„¶','ã„·','ã„¹','ã„º','ã„»','ã„¼','ã„½','ã„¾','ã„¿','ã…€','ã…','ã…‚','ã…„','ã……','ã…†','ã…‡','ã…ˆ','ã…Š','ã…‹','ã…Œ','ã…','ã…'];
            
            return {
                cho: cho[choIndex],
                jung: jung[jungIndex],
                jong: jong[jongIndex]
            };
        }

        // í•œêµ­ì–´ ìëª¨ì—ì„œ ë°œìŒ ì¶”ì¶œ
        function getPhonemeFromJamo(jamo, isJong = false) {
            const vowelMap = {
                'ã…': 'a', 'ã…‘': 'a',
                'ã…': 'ae', 'ã…’': 'ae',
                'ã…“': 'eo', 'ã…•': 'eo',
                'ã…”': 'e', 'ã…–': 'e',
                'ã…—': 'o', 'ã…›': 'o',
                'ã…˜': 'o', 'ã…™': 'ae', 'ã…š': 'o',
                'ã…œ': 'u', 'ã… ': 'u',
                'ã…': 'u', 'ã…': 'e', 'ã…Ÿ': 'u',
                'ã…¡': 'eu',
                'ã…¢': 'eu',
                'ã…£': 'i'
            };
            
            const consonantMap = {
                'ã…‚': 'b_p_m', 'ã…ƒ': 'b_p_m', 'ã…': 'b_p_m',
                'ã…': 'b_p_m',
                'ã„´': 'n', 'ã„¹': 'n',
                'ã……': 's', 'ã…†': 's',
                'ã…Œ': 't_d', 'ã„·': 't_d', 'ã„¸': 't_d',
                'ã„±': 'g_k', 'ã„²': 'g_k', 'ã…‹': 'g_k',
                'ã…ˆ': 'j', 'ã…‰': 'j', 'ã…Š': 'j',
                'ã…': 'h',
                'ã…‡': isJong ? 'ng' : null
            };
            
            const jongConsonantMap = {
                'ã„±': 'g_k', 'ã„²': 'g_k', 'ã„³': 'g_k',
                'ã„´': 'n', 'ã„µ': 'n', 'ã„¶': 'n',
                'ã„·': 't_d', 'ã„¹': 'n',
                'ã„º': 'g_k', 'ã„»': 'b_p_m', 'ã„¼': 'b_p_m',
                'ã„½': 's', 'ã„¾': 't_d', 'ã„¿': 'b_p_m', 'ã…€': 'n',
                'ã…': 'b_p_m',
                'ã…‚': 'b_p_m', 'ã…„': 'b_p_m',
                'ã……': 't_d', 'ã…†': 't_d',
                'ã…‡': 'ng',
                'ã…ˆ': 't_d', 'ã…Š': 't_d',
                'ã…‹': 'g_k', 'ã…Œ': 't_d', 'ã…': 'b_p_m', 'ã…': 't_d'
            };
            
            if (vowelMap[jamo]) return vowelMap[jamo];
            if (isJong && jongConsonantMap[jamo]) return jongConsonantMap[jamo];
            if (consonantMap[jamo]) return consonantMap[jamo];
            
            return 'rest';
        }

        // ì˜ì–´ ë¬¸ìì—ì„œ ë°œìŒ ì¶”ì¶œ (ê°„ë‹¨í•œ ê·œì¹™ ê¸°ë°˜)
        function getEnglishPhoneme(char, nextChar = null) {
            char = char.toLowerCase();
            
            // ëª¨ìŒ
            const vowels = {
                'a': 'AE', 'e': 'EH', 'i': 'IH', 'o': 'OW', 'u': 'UH'
            };
            
            // ììŒ
            const consonants = {
                'b': 'B', 'p': 'P', 'm': 'M',
                'f': 'F', 'v': 'V',
                's': 'S', 'z': 'Z',
                't': 'T', 'd': 'D',
                'n': 'N', 'l': 'L', 'r': 'R',
                'k': 'K', 'c': 'K', 'g': 'G',
                'h': 'H', 'w': 'W', 'y': 'Y',
                'j': 'JH', 'q': 'K', 'x': 'K'
            };
            
            // íŠ¹ìˆ˜ ì¡°í•©
            if (char === 's' && nextChar === 'h') return 'SH';
            if (char === 'c' && nextChar === 'h') return 'CH';
            if (char === 't' && nextChar === 'h') return 'TH';
            
            if (vowels[char]) return vowels[char];
            if (consonants[char]) return consonants[char];
            
            return 'rest';
        }

        // í…ìŠ¤íŠ¸ê°€ í•œêµ­ì–´ì¸ì§€ ì˜ì–´ì¸ì§€ ê°ì§€
        function detectLanguage(text) {
            const koreanRegex = /[\uAC00-\uD7AF\u1100-\u11FF\u3130-\u318F]/;
            const englishRegex = /[a-zA-Z]/;
            
            const hasKorean = koreanRegex.test(text);
            const hasEnglish = englishRegex.test(text);
            
            // í•œêµ­ì–´ê°€ ë” ë§ìœ¼ë©´ í•œêµ­ì–´ë¡œ ì²˜ë¦¬
            const koreanCount = (text.match(koreanRegex) || []).length;
            const englishCount = (text.match(englishRegex) || []).length;
            
            return koreanCount > englishCount ? 'korean' : 'english';
        }

        // í•œêµ­ì–´ í…ìŠ¤íŠ¸ë¥¼ ë°œìŒ ì‹œí€€ìŠ¤ë¡œ ë³€í™˜
        function koreanTextToPhonemes(text) {
            const phonemes = [];
            
            for (let i = 0; i < text.length; i++) {
                const char = text[i];
                
                if (char === ' ') {
                    phonemes.push({ phoneme: 'rest', duration: 150, map: phonemeMapKorean });
                    continue;
                } else if (char === ',' || char === '.') {
                    phonemes.push({ phoneme: 'rest', duration: 250, map: phonemeMapKorean });
                    continue;
                } else if (char === '!' || char === '?') {
                    phonemes.push({ phoneme: 'rest', duration: 300, map: phonemeMapKorean });
                    continue;
                }
                
                const decomposed = decomposeHangul(char);
                if (!decomposed) {
                    phonemes.push({ phoneme: 'rest', duration: 100, map: phonemeMapKorean });
                    continue;
                }
                
                // ì´ˆì„± + ì¤‘ì„± + ì¢…ì„±ì„ í•˜ë‚˜ì˜ ìŒì ˆë¡œ ì²˜ë¦¬
                let syllablePhonemes = [];
                
                if (decomposed.cho && decomposed.cho !== 'ã…‡') {
                    const choPhoneme = getPhonemeFromJamo(decomposed.cho, false);
                    if (choPhoneme) {
                        syllablePhonemes.push({
                            phoneme: choPhoneme,
                            duration: 60,
                            map: phonemeMapKorean
                        });
                    }
                }
                
                const jungPhoneme = getPhonemeFromJamo(decomposed.jung, false);
                syllablePhonemes.push({
                    phoneme: jungPhoneme,
                    duration: 180,
                    map: phonemeMapKorean
                });
                
                if (decomposed.jong) {
                    const jongPhoneme = getPhonemeFromJamo(decomposed.jong, true);
                    if (jongPhoneme) {
                        const nextChar = text[i + 1];
                        const nextDecomposed = nextChar ? decomposeHangul(nextChar) : null;
                        
                        if (nextDecomposed && nextDecomposed.cho === 'ã…‡') {
                            syllablePhonemes.push({
                                phoneme: jongPhoneme,
                                duration: 40,
                                map: phonemeMapKorean
                            });
                        } else {
                            syllablePhonemes.push({
                                phoneme: jongPhoneme,
                                duration: 80,
                                map: phonemeMapKorean
                            });
                        }
                    }
                }
                
                // ìŒì ˆì˜ ëª¨ë“  ë°œìŒ ì¶”ê°€
                phonemes.push(...syllablePhonemes);
                
                // ìŒì ˆ ì‚¬ì´ ë¯¸ì„¸í•œ ê°„ê²© (ê°™ì€ ê¸€ìê°€ ë°˜ë³µë  ë•ŒëŠ” ì¶”ê°€í•˜ì§€ ì•ŠìŒ)
                if (i < text.length - 1 && text[i + 1] !== ' ' && text[i] !== text[i + 1]) {
                    phonemes.push({ phoneme: 'rest', duration: 20, map: phonemeMapKorean });
                }
            }
            
            return phonemes;
        }

        // ì˜ì–´ í…ìŠ¤íŠ¸ë¥¼ ë°œìŒ ì‹œí€€ìŠ¤ë¡œ ë³€í™˜
        function englishTextToPhonemes(text) {
            const phonemes = [];
            
            for (let i = 0; i < text.length; i++) {
                const char = text[i];
                const nextChar = text[i + 1];
                
                if (char === ' ') {
                    phonemes.push({ phoneme: 'rest', duration: 120, map: phonemeMapEnglish });
                    continue;
                } else if (char === ',' || char === '.') {
                    phonemes.push({ phoneme: 'rest', duration: 200, map: phonemeMapEnglish });
                    continue;
                } else if (char === '!' || char === '?') {
                    phonemes.push({ phoneme: 'rest', duration: 250, map: phonemeMapEnglish });
                    continue;
                } else if (!/[a-zA-Z]/.test(char)) {
                    phonemes.push({ phoneme: 'rest', duration: 80, map: phonemeMapEnglish });
                    continue;
                }
                
                const phoneme = getEnglishPhoneme(char, nextChar);
                
                // sh, ch, th ê°™ì€ ì¡°í•© ì²˜ë¦¬
                if ((char === 's' || char === 'c' || char === 't') && nextChar === 'h') {
                    phonemes.push({
                        phoneme: phoneme,
                        duration: 140,
                        map: phonemeMapEnglish
                    });
                    i++; // ë‹¤ìŒ 'h' ê±´ë„ˆë›°ê¸°
                    continue;
                }
                
                // ëª¨ìŒì€ ê¸¸ê²Œ, ììŒì€ ì§§ê²Œ
                const isVowel = 'aeiouAEIOU'.includes(char);
                phonemes.push({
                    phoneme: phoneme,
                    duration: isVowel ? 150 : 80,
                    map: phonemeMapEnglish
                });
            }
            
            return phonemes;
        }

        // í˜¼í•© í…ìŠ¤íŠ¸ë¥¼ ë°œìŒ ì‹œí€€ìŠ¤ë¡œ ë³€í™˜
        function textToPhonemes(text) {
            const phonemes = [];
            let currentSegment = '';
            let currentLang = null;
            
            for (let i = 0; i < text.length; i++) {
                const char = text[i];
                const isKorean = /[\uAC00-\uD7AF]/.test(char);
                const isEnglish = /[a-zA-Z]/.test(char);
                
                if (isKorean) {
                    if (currentLang === 'english' && currentSegment) {
                        phonemes.push(...englishTextToPhonemes(currentSegment));
                        currentSegment = '';
                    }
                    currentLang = 'korean';
                    currentSegment += char;
                } else if (isEnglish) {
                    if (currentLang === 'korean' && currentSegment) {
                        phonemes.push(...koreanTextToPhonemes(currentSegment));
                        currentSegment = '';
                    }
                    currentLang = 'english';
                    currentSegment += char;
                } else {
                    if (currentSegment) {
                        if (currentLang === 'korean') {
                            phonemes.push(...koreanTextToPhonemes(currentSegment));
                        } else if (currentLang === 'english') {
                            phonemes.push(...englishTextToPhonemes(currentSegment));
                        }
                        currentSegment = '';
                    }
                    
                    // ê³µë°±ì´ë‚˜ êµ¬ë‘ì  ì²˜ë¦¬ (ì‰¬ëŠ” êµ¬ê°„ì„ ë” ê¸¸ê²Œ)
                    if (char === ' ') {
                        phonemes.push({ phoneme: 'rest', duration: 300, map: phonemeMapKorean });
                    } else if (char === ',') {
                        phonemes.push({ phoneme: 'rest', duration: 500, map: phonemeMapKorean });
                    } else if (char === '.') {
                        phonemes.push({ phoneme: 'rest', duration: 600, map: phonemeMapKorean });
                    } else if (char === '!' || char === '?') {
                        phonemes.push({ phoneme: 'rest', duration: 700, map: phonemeMapKorean });
                    } else if (char === '\n') {
                        // ì¤„ë°”ê¿ˆì€ ë” ê¸´ íœ´ì§€ êµ¬ê°„
                        phonemes.push({ phoneme: 'rest', duration: 800, map: phonemeMapKorean });
                    }
                    currentLang = null;
                }
            }
            
            // ë‚¨ì€ ì„¸ê·¸ë¨¼íŠ¸ ì²˜ë¦¬
            if (currentSegment) {
                if (currentLang === 'korean') {
                    phonemes.push(...koreanTextToPhonemes(currentSegment));
                } else if (currentLang === 'english') {
                    phonemes.push(...englishTextToPhonemes(currentSegment));
                }
            }
            
            return phonemes;
        }

        // ë¦½ì‹±í¬ ì• ë‹ˆë©”ì´ì…˜
        function animateLipSync(text) {
            const phonemeSequence = textToPhonemes(text);
            let index = 0;
            
            console.log('ë¦½ì‹±í¬ ì‹œì‘, ì´', phonemeSequence.length, 'ê°œ ë°œìŒ');
            
            function nextPhoneme() {
                if (!isSpeaking || index >= phonemeSequence.length) {
                    currentMouthIndex = phonemeMapKorean['rest'];
                    drawCurrentMouth();
                    return;
                }
                
                const { phoneme, duration, map } = phonemeSequence[index];
                currentMouthIndex = map[phoneme] || map['rest'];
                drawCurrentMouth();
                
                index++;
                
                // ë‹¤ìŒ ë°œìŒë„ ê°™ì€ phonemeì´ë©´ durationì„ í•©ì‚°í•˜ì—¬ ê°™ì€ ì… ëª¨ì–‘ ìœ ì§€
                let totalDuration = duration;
                while (index < phonemeSequence.length && 
                       phonemeSequence[index].phoneme === phoneme &&
                       phonemeSequence[index].map === map) {
                    totalDuration += phonemeSequence[index].duration;
                    index++;
                }
                
                animationInterval = setTimeout(nextPhoneme, totalDuration / speechRate);
            }
            
            nextPhoneme();
        }

        function loadMouthImage(event) {
            const file = event.target.files[0];
            if (!file) return;
            
            const reader = new FileReader();
            reader.onload = function(e) {
                const img = new Image();
                img.onload = function() {
                    mouthSpriteSheet = img;
                    updateGrid();
                };
                img.src = e.target.result;
            };
            reader.readAsDataURL(file);
        }

        function updateGrid() {
            rows = parseInt(document.getElementById('gridRows').value);
            cols = parseInt(document.getElementById('gridCols').value);
            
            if (mouthSpriteSheet) {
                extractMouthFrames();
                displayPreviewGrid();
                displayPhonemeMapping();
                drawCurrentMouth();
                updateStatus('âœ… ì¤€ë¹„ ì™„ë£Œ! ë§í•˜ê¸°ë¥¼ ì‹œì‘í•˜ì„¸ìš”.', 'idle');
            }
        }

        function detectMouthBounds(canvas) {
            const ctx = canvas.getContext('2d');
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const data = imageData.data;
            
            let minX = canvas.width;
            let minY = canvas.height;
            let maxX = 0;
            let maxY = 0;
            
            for (let y = 0; y < canvas.height; y++) {
                for (let x = 0; x < canvas.width; x++) {
                    const idx = (y * canvas.width + x) * 4;
                    const alpha = data[idx + 3];
                    
                    if (alpha > 10) {
                        const r = data[idx];
                        const g = data[idx + 1];
                        const b = data[idx + 2];
                        
                        if (r < 240 || g < 240 || b < 240) {
                            minX = Math.min(minX, x);
                            minY = Math.min(minY, y);
                            maxX = Math.max(maxX, x);
                            maxY = Math.max(maxY, y);
                        }
                    }
                }
            }
            
            if (minX >= maxX || minY >= maxY) {
                return { x: 0, y: 0, width: canvas.width, height: canvas.height };
            }
            
            const padding = 5;
            minX = Math.max(0, minX - padding);
            minY = Math.max(0, minY - padding);
            maxX = Math.min(canvas.width, maxX + padding);
            maxY = Math.min(canvas.height, maxY + padding);
            
            return {
                x: minX,
                y: minY,
                width: maxX - minX,
                height: maxY - minY,
                centerX: (minX + maxX) / 2,
                centerY: (minY + maxY) / 2
            };
        }

        function extractMouthFrames() {
            if (!mouthSpriteSheet) return;
            
            mouthFrames = [];
            const frameWidth = mouthSpriteSheet.width / cols;
            const frameHeight = mouthSpriteSheet.height / rows;
            
            for (let row = 0; row < rows; row++) {
                for (let col = 0; col < cols; col++) {
                    const tempCanvas = document.createElement('canvas');
                    tempCanvas.width = frameWidth;
                    tempCanvas.height = frameHeight;
                    const tempCtx = tempCanvas.getContext('2d');
                    
                    tempCtx.drawImage(
                        mouthSpriteSheet,
                        col * frameWidth,
                        row * frameHeight,
                        frameWidth,
                        frameHeight,
                        0, 0,
                        frameWidth,
                        frameHeight
                    );
                    
                    const bounds = detectMouthBounds(tempCanvas);
                    
                    mouthFrames.push({
                        canvas: tempCanvas,
                        bounds: bounds
                    });
                }
            }
        }

        function displayPreviewGrid() {
            const previewGrid = document.getElementById('previewGrid');
            previewGrid.innerHTML = '';
            previewGrid.style.display = 'grid';
            previewGrid.style.gridTemplateColumns = `repeat(${cols}, 1fr)`;
            
            mouthFrames.forEach((frame, index) => {
                const container = document.createElement('div');
                container.style.position = 'relative';
                
                const img = document.createElement('img');
                img.src = frame.canvas.toDataURL();
                img.className = 'preview-mouth';
                if (index === currentMouthIndex) {
                    img.classList.add('selected');
                }
                img.onclick = () => {
                    document.querySelectorAll('.preview-mouth').forEach(m => m.classList.remove('selected'));
                    img.classList.add('selected');
                    currentMouthIndex = index;
                    drawCurrentMouth();
                };
                
                const label = document.createElement('div');
                label.className = 'mouth-label';
                label.textContent = index;
                
                container.appendChild(img);
                container.appendChild(label);
                previewGrid.appendChild(container);
            });
        }

        function switchLanguage(lang) {
            currentMappingLanguage = lang;
            
            document.querySelectorAll('.lang-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            event.target.classList.add('active');
            
            if (lang === 'korean') {
                document.getElementById('phonemeMappingKorean').style.display = 'block';
                document.getElementById('phonemeMappingEnglish').style.display = 'none';
            } else {
                document.getElementById('phonemeMappingKorean').style.display = 'none';
                document.getElementById('phonemeMappingEnglish').style.display = 'block';
            }
        }

        function switchAudioMode(mode) {
            audioMode = mode;
            
            const buttons = document.querySelectorAll('#uploadMode').parentElement.querySelectorAll('.lang-btn');
            buttons.forEach(btn => btn.classList.remove('active'));
            
            if (mode === 'tts') {
                document.getElementById('ttsMode').style.display = 'block';
                document.getElementById('uploadMode').style.display = 'none';
                buttons[0].classList.add('active');
            } else {
                document.getElementById('ttsMode').style.display = 'none';
                document.getElementById('uploadMode').style.display = 'block';
                buttons[1].classList.add('active');
            }
        }

        function switchTTSEngine(engine) {
            ttsEngine = engine;
            
            const buttons = document.querySelectorAll('#ttsMode .lang-toggle')[0].querySelectorAll('.lang-btn');
            buttons.forEach(btn => btn.classList.remove('active'));
            
            if (engine === 'browser') {
                document.getElementById('browserTTSSettings').style.display = 'block';
                document.getElementById('googleTTSSettings').style.display = 'none';
                buttons[0].classList.add('active');
            } else {
                document.getElementById('browserTTSSettings').style.display = 'none';
                document.getElementById('googleTTSSettings').style.display = 'block';
                buttons[1].classList.add('active');
            }
        }

        // Google Cloud TTSë¥¼ ì‚¬ìš©í•œ ìŒì„± í•©ì„±
        async function synthesizeWithGoogleTTS(text) {
            const apiKey = document.getElementById('googleTTSApiKey').value.trim();
            if (!apiKey) {
                alert('Google Cloud TTS API í‚¤ë¥¼ ì…ë ¥í•´ì£¼ì„¸ìš”!\n\n1. https://console.cloud.google.com ì ‘ì†\n2. Text-to-Speech API í™œì„±í™”\n3. API Key ìƒì„±\n4. ìœ„ ì…ë ¥ë€ì— ë¶™ì—¬ë„£ê¸°');
                return null;
            }
            
            const voiceName = document.getElementById('googleVoiceSelect').value;
            const languageCode = voiceName.split('-').slice(0, 2).join('-'); // 'ko-KR'
            
            try {
                updateStatus('ğŸ™ï¸ Google TTS ìŒì„± ìƒì„± ì¤‘...', 'speaking');
                
                const response = await fetch(`https://texttospeech.googleapis.com/v1/text:synthesize?key=${apiKey}`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        input: { text: text },
                        voice: {
                            languageCode: languageCode,
                            name: voiceName
                        },
                        audioConfig: {
                            audioEncoding: 'MP3',
                            speakingRate: speechRate,
                            pitch: 0.0,
                            volumeGainDb: 0.0
                        }
                    })
                });
                
                if (!response.ok) {
                    const errorData = await response.json();
                    console.error('Google TTS ì˜¤ë¥˜:', errorData);
                    throw new Error(`API ì˜¤ë¥˜ (${response.status}): ${errorData.error?.message || 'ì•Œ ìˆ˜ ì—†ëŠ” ì˜¤ë¥˜'}`);
                }
                
                const data = await response.json();
                
                // Base64ë¡œ ì¸ì½”ë”©ëœ ì˜¤ë””ì˜¤ ë°ì´í„°ë¥¼ Blobìœ¼ë¡œ ë³€í™˜
                const audioContent = data.audioContent;
                const audioBlob = base64ToBlob(audioContent, 'audio/mp3');
                const audioUrl = URL.createObjectURL(audioBlob);
                
                console.log('Google TTS ìŒì„± ìƒì„± ì™„ë£Œ');
                return audioUrl;
                
            } catch (error) {
                console.error('Google TTS ì „ì²´ ì˜¤ë¥˜:', error);
                updateStatus('âŒ Google TTS ì‹¤íŒ¨', 'idle');
                alert(`Google TTS ì˜¤ë¥˜: ${error.message}\n\ní™•ì¸ì‚¬í•­:\nâ€¢ API í‚¤ê°€ ì˜¬ë°”ë¥¸ì§€ í™•ì¸\nâ€¢ Text-to-Speech APIê°€ í™œì„±í™”ë˜ì–´ ìˆëŠ”ì§€ í™•ì¸\nâ€¢ ë¸Œë¼ìš°ì € ì½˜ì†”(F12)ì—ì„œ ìì„¸í•œ ì˜¤ë¥˜ í™•ì¸`);
                return null;
            }
        }

        // Base64ë¥¼ Blobìœ¼ë¡œ ë³€í™˜
        function base64ToBlob(base64, mimeType) {
            const byteCharacters = atob(base64);
            const byteArrays = [];
            
            for (let offset = 0; offset < byteCharacters.length; offset += 512) {
                const slice = byteCharacters.slice(offset, offset + 512);
                const byteNumbers = new Array(slice.length);
                
                for (let i = 0; i < slice.length; i++) {
                    byteNumbers[i] = slice.charCodeAt(i);
                }
                
                const byteArray = new Uint8Array(byteNumbers);
                byteArrays.push(byteArray);
            }
            
            return new Blob(byteArrays, { type: mimeType });
        }

        function switchAudioMode(mode) {
            audioMode = mode;
            
            const buttons = document.querySelectorAll('#uploadMode').length > 0 ? 
                document.querySelectorAll('.lang-toggle')[1].querySelectorAll('.lang-btn') :
                document.querySelectorAll('.lang-toggle')[0].querySelectorAll('.lang-btn');
            
            buttons.forEach(btn => btn.classList.remove('active'));
            event.target.classList.add('active');
            
            if (mode === 'tts') {
                document.getElementById('ttsMode').style.display = 'block';
                document.getElementById('uploadMode').style.display = 'none';
            } else {
                document.getElementById('ttsMode').style.display = 'none';
                document.getElementById('uploadMode').style.display = 'block';
            }
        }

        function loadAudioFile(event) {
            const file = event.target.files[0];
            if (!file) return;
            
            const reader = new FileReader();
            reader.onload = function(e) {
                // ê¸°ì¡´ ì˜¤ë””ì˜¤ ì •ë¦¬
                if (uploadedAudio) {
                    uploadedAudio.pause();
                    uploadedAudio = null;
                }
                
                // ê¸°ì¡´ ì˜¤ë””ì˜¤ ì†ŒìŠ¤ ì •ë¦¬ (ì¤‘ìš”!)
                if (audioSource) {
                    try {
                        audioSource.disconnect();
                    } catch (e) {}
                    audioSource = null;
                }
                if (analyser) {
                    try {
                        analyser.disconnect();
                    } catch (e) {}
                    analyser = null;
                }
                
                uploadedAudio = new Audio(e.target.result);
                
                uploadedAudio.addEventListener('loadedmetadata', () => {
                    const duration = uploadedAudio.duration;
                    document.getElementById('audioFileName').textContent = file.name;
                    document.getElementById('audioDuration').textContent = duration.toFixed(2);
                    document.getElementById('audioInfo').style.display = 'block';
                    
                    console.log('ì˜¤ë””ì˜¤ ë¡œë“œ ì™„ë£Œ:', {
                        íŒŒì¼: file.name,
                        ê¸¸ì´: duration + 'ì´ˆ'
                    });
                    
                    updateStatus('âœ… ì˜¤ë””ì˜¤ íŒŒì¼ ë¡œë“œ ì™„ë£Œ! ìŒì„± ì¸ì‹ì„ ì‹œë„í•˜ê±°ë‚˜ ì§ì ‘ í…ìŠ¤íŠ¸ë¥¼ ì…ë ¥í•˜ì„¸ìš”.', 'idle');
                });
                
                uploadedAudio.addEventListener('error', (e) => {
                    console.error('ì˜¤ë””ì˜¤ ë¡œë“œ ì‹¤íŒ¨:', e);
                    alert('ì˜¤ë””ì˜¤ íŒŒì¼ì„ ë¡œë“œí•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.');
                    updateStatus('âŒ ì˜¤ë””ì˜¤ ë¡œë“œ ì‹¤íŒ¨', 'idle');
                });
            };
            reader.readAsDataURL(file);
        }

        // AssemblyAIë¥¼ ì‚¬ìš©í•œ ìŒì„±ì¸ì‹
        async function transcribeWithAssembly() {
            if (!uploadedAudio) {
                alert('ë¨¼ì € ì˜¤ë””ì˜¤ íŒŒì¼ì„ ì—…ë¡œë“œí•´ì£¼ì„¸ìš”!');
                return;
            }
            
            const apiKey = document.getElementById('assemblyApiKey').value.trim();
            if (!apiKey) {
                alert('AssemblyAI API í‚¤ë¥¼ ì…ë ¥í•´ì£¼ì„¸ìš”!\n\n1. https://www.assemblyai.com/dashboard ë°©ë¬¸\n2. API Key ë³µì‚¬\n3. ìœ„ ì…ë ¥ë€ì— ë¶™ì—¬ë„£ê¸°');
                return;
            }
            
            const statusEl = document.getElementById('transcriptionStatus');
            const textEl = document.getElementById('transcriptionText');
            
            statusEl.style.display = 'block';
            statusEl.style.background = '#dbeafe';
            textEl.innerHTML = 'ğŸ“¤ ì˜¤ë””ì˜¤ ì—…ë¡œë“œ ì¤‘...';
            
            try {
                const audioFile = document.getElementById('audioUpload').files[0];
                if (!audioFile) {
                    throw new Error('ì˜¤ë””ì˜¤ íŒŒì¼ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.');
                }
                
                console.log('íŒŒì¼ ì •ë³´:', {
                    ì´ë¦„: audioFile.name,
                    í¬ê¸°: (audioFile.size / 1024 / 1024).toFixed(2) + 'MB',
                    íƒ€ì…: audioFile.type
                });
                
                // 1ë‹¨ê³„: ì˜¤ë””ì˜¤ íŒŒì¼ì„ AssemblyAIì— ì—…ë¡œë“œ
                textEl.innerHTML = 'ğŸ“¤ ì˜¤ë””ì˜¤ ì—…ë¡œë“œ ì¤‘... (1/3)';
                
                const uploadResponse = await fetch('https://api.assemblyai.com/v2/upload', {
                    method: 'POST',
                    headers: {
                        'authorization': apiKey,
                        'content-type': audioFile.type || 'audio/mpeg'
                    },
                    body: audioFile
                });
                
                console.log('ì—…ë¡œë“œ ì‘ë‹µ ìƒíƒœ:', uploadResponse.status);
                
                if (!uploadResponse.ok) {
                    const errorText = await uploadResponse.text();
                    console.error('ì—…ë¡œë“œ ì˜¤ë¥˜:', errorText);
                    throw new Error(`ì˜¤ë””ì˜¤ ì—…ë¡œë“œ ì‹¤íŒ¨ (${uploadResponse.status}): ${errorText}`);
                }
                
                const uploadData = await uploadResponse.json();
                const upload_url = uploadData.upload_url;
                console.log('ì—…ë¡œë“œ ì™„ë£Œ:', upload_url);
                
                // 2ë‹¨ê³„: ìŒì„±ì¸ì‹ ìš”ì²­
                textEl.innerHTML = 'ğŸ¤ ìŒì„± ì¸ì‹ ì¤‘... (2/3)';
                
                const transcriptResponse = await fetch('https://api.assemblyai.com/v2/transcript', {
                    method: 'POST',
                    headers: {
                        'authorization': apiKey,
                        'content-type': 'application/json'
                    },
                    body: JSON.stringify({
                        audio_url: upload_url,
                        language_code: 'ko', // í•œêµ­ì–´
                        speech_models: ['universal-2'] // í•„ìˆ˜: ìŒì„± ëª¨ë¸ ì§€ì •
                    })
                });
                
                console.log('ì¸ì‹ ìš”ì²­ ì‘ë‹µ ìƒíƒœ:', transcriptResponse.status);
                
                if (!transcriptResponse.ok) {
                    const errorText = await transcriptResponse.text();
                    console.error('ì¸ì‹ ìš”ì²­ ì˜¤ë¥˜:', errorText);
                    throw new Error(`ìŒì„±ì¸ì‹ ìš”ì²­ ì‹¤íŒ¨ (${transcriptResponse.status}): ${errorText}`);
                }
                
                const transcriptData = await transcriptResponse.json();
                const id = transcriptData.id;
                console.log('ì¸ì‹ ì‘ì—… ID:', id);
                
                // 3ë‹¨ê³„: ê²°ê³¼ í´ë§
                textEl.innerHTML = 'â³ ì²˜ë¦¬ ì¤‘... (3/3)<br>ì¡°ê¸ˆë§Œ ê¸°ë‹¤ë ¤ì£¼ì„¸ìš”...';
                
                let transcript;
                let pollCount = 0;
                const maxPolls = 60; // ìµœëŒ€ 2ë¶„ ëŒ€ê¸°
                
                while (pollCount < maxPolls) {
                    await new Promise(resolve => setTimeout(resolve, 2000)); // 2ì´ˆ ëŒ€ê¸°
                    pollCount++;
                    
                    const pollingResponse = await fetch(`https://api.assemblyai.com/v2/transcript/${id}`, {
                        headers: {
                            'authorization': apiKey
                        }
                    });
                    
                    if (!pollingResponse.ok) {
                        const errorText = await pollingResponse.text();
                        console.error('í´ë§ ì˜¤ë¥˜:', errorText);
                        throw new Error(`ê²°ê³¼ í™•ì¸ ì‹¤íŒ¨ (${pollingResponse.status})`);
                    }
                    
                    transcript = await pollingResponse.json();
                    console.log('ì²˜ë¦¬ ìƒíƒœ:', transcript.status);
                    
                    if (transcript.status === 'completed') {
                        break;
                    } else if (transcript.status === 'error') {
                        throw new Error(transcript.error || 'ìŒì„±ì¸ì‹ ì‹¤íŒ¨');
                    }
                    
                    // ì§„í–‰ë¥  í‘œì‹œ
                    textEl.innerHTML = `â³ ì²˜ë¦¬ ì¤‘... (3/3)<br>ìƒíƒœ: ${transcript.status}<br>ëŒ€ê¸° ì‹œê°„: ${pollCount * 2}ì´ˆ`;
                }
                
                if (pollCount >= maxPolls) {
                    throw new Error('ì²˜ë¦¬ ì‹œê°„ ì´ˆê³¼ (2ë¶„)');
                }
                
                // ê²°ê³¼ë¥¼ í…ìŠ¤íŠ¸ í•„ë“œì— ì…ë ¥
                const recognizedText = transcript.text || '';
                
                if (!recognizedText) {
                    throw new Error('ì¸ì‹ëœ í…ìŠ¤íŠ¸ê°€ ì—†ìŠµë‹ˆë‹¤. ì˜¤ë””ì˜¤ì— ìŒì„±ì´ ìˆëŠ”ì§€ í™•ì¸í•˜ì„¸ìš”.');
                }
                
                document.getElementById('textInputUpload').value = recognizedText;
                
                const confidence = transcript.confidence ? (transcript.confidence * 100).toFixed(1) : 'N/A';
                
                statusEl.style.background = '#d1fae5';
                textEl.innerHTML = `âœ… ìŒì„± ì¸ì‹ ì™„ë£Œ!<br>ì¸ì‹ëœ í…ìŠ¤íŠ¸: ${recognizedText.length}ì<br>ì‹ ë¢°ë„: ${confidence}%`;
                
                console.log('AssemblyAI ì¸ì‹ ì™„ë£Œ:', recognizedText);
                
                updateStatus('âœ… ìŒì„± ì¸ì‹ ì™„ë£Œ!', 'idle');
                
            } catch (error) {
                console.error('AssemblyAI ì „ì²´ ì˜¤ë¥˜:', error);
                statusEl.style.background = '#fee2e2';
                textEl.innerHTML = `âŒ ìŒì„± ì¸ì‹ ì‹¤íŒ¨<br>ì˜¤ë¥˜: ${error.message}<br><br>ğŸ’¡ í™•ì¸ì‚¬í•­:<br>â€¢ API í‚¤ê°€ ì˜¬ë°”ë¥¸ì§€ í™•ì¸<br>â€¢ ì˜¤ë””ì˜¤ íŒŒì¼ í˜•ì‹ í™•ì¸ (MP3, WAV ê¶Œì¥)<br>â€¢ ë¸Œë¼ìš°ì € ì½˜ì†”(F12)ì—ì„œ ìì„¸í•œ ì˜¤ë¥˜ í™•ì¸`;
                updateStatus('âŒ ìŒì„± ì¸ì‹ ì‹¤íŒ¨', 'idle');
            }
        }

        // OpenAI Whisper APIë¥¼ ì‚¬ìš©í•œ ìŒì„±ì¸ì‹
        async function transcribeWithWhisper() {
            if (!uploadedAudio) {
                alert('ë¨¼ì € ì˜¤ë””ì˜¤ íŒŒì¼ì„ ì—…ë¡œë“œí•´ì£¼ì„¸ìš”!');
                return;
            }
            
            const apiKey = document.getElementById('openaiApiKey').value.trim();
            if (!apiKey) {
                alert('OpenAI API í‚¤ë¥¼ ì…ë ¥í•´ì£¼ì„¸ìš”!\n\n1. https://platform.openai.com/api-keys ë°©ë¬¸\n2. API í‚¤ ìƒì„±\n3. ìœ„ ì…ë ¥ë€ì— ë¶™ì—¬ë„£ê¸°');
                return;
            }
            
            const statusEl = document.getElementById('transcriptionStatus');
            const textEl = document.getElementById('transcriptionText');
            
            statusEl.style.display = 'block';
            statusEl.style.background = '#dbeafe';
            textEl.innerHTML = 'ğŸ¤ ìŒì„± ì¸ì‹ ì¤‘... (Whisper API)';
            
            try {
                // ì˜¤ë””ì˜¤ íŒŒì¼ì„ ì—…ë¡œë“œí•  ìˆ˜ ìˆë„ë¡ ë³€í™˜
                const audioFile = document.getElementById('audioUpload').files[0];
                if (!audioFile) {
                    throw new Error('ì˜¤ë””ì˜¤ íŒŒì¼ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.');
                }
                
                // FormData ìƒì„±
                const formData = new FormData();
                formData.append('file', audioFile);
                formData.append('model', 'whisper-1');
                formData.append('language', 'ko'); // í•œêµ­ì–´ ìš°ì„ 
                formData.append('response_format', 'text');
                
                // Whisper API í˜¸ì¶œ
                const response = await fetch('https://api.openai.com/v1/audio/transcriptions', {
                    method: 'POST',
                    headers: {
                        'Authorization': `Bearer ${apiKey}`
                    },
                    body: formData
                });
                
                if (!response.ok) {
                    const error = await response.json();
                    throw new Error(error.error?.message || 'API ìš”ì²­ ì‹¤íŒ¨');
                }
                
                const transcription = await response.text();
                
                // ê²°ê³¼ë¥¼ í…ìŠ¤íŠ¸ í•„ë“œì— ì…ë ¥
                document.getElementById('textInputUpload').value = transcription;
                
                statusEl.style.background = '#d1fae5';
                textEl.innerHTML = `âœ… ìŒì„± ì¸ì‹ ì™„ë£Œ!<br>ì¸ì‹ëœ í…ìŠ¤íŠ¸: ${transcription.length}ì`;
                
                console.log('Whisper ì¸ì‹ ì™„ë£Œ:', transcription);
                
                updateStatus('âœ… ìŒì„± ì¸ì‹ ì™„ë£Œ!', 'idle');
                
            } catch (error) {
                console.error('Whisper API ì˜¤ë¥˜:', error);
                statusEl.style.background = '#fee2e2';
                textEl.innerHTML = `âŒ ìŒì„± ì¸ì‹ ì‹¤íŒ¨<br>ì˜¤ë¥˜: ${error.message}<br><br>ğŸ’¡ API í‚¤ê°€ ì˜¬ë°”ë¥¸ì§€ í™•ì¸í•˜ì„¸ìš”.`;
                updateStatus('âŒ ìŒì„± ì¸ì‹ ì‹¤íŒ¨', 'idle');
            }
        }

        // Web Speech APIë¥¼ í™œìš©í•œ ìŒì„± ì¸ì‹ (ì˜¤ë””ì˜¤ ì¬ìƒ + ë§ˆì´í¬ ì¸ì‹)
        async function transcribeAudio() {
            if (!uploadedAudio) {
                alert('ë¨¼ì € ì˜¤ë””ì˜¤ íŒŒì¼ì„ ì—…ë¡œë“œí•´ì£¼ì„¸ìš”!');
                return;
            }

            const statusEl = document.getElementById('transcriptionStatus');
            const textEl = document.getElementById('transcriptionText');
            
            // SpeechRecognition ì§€ì› í™•ì¸
            const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
            
            if (!SpeechRecognition) {
                statusEl.style.display = 'block';
                statusEl.style.background = '#f8d7da';
                textEl.innerHTML = `
                    âŒ <strong>ìŒì„± ì¸ì‹ ë¯¸ì§€ì›</strong><br>
                    ì´ ë¸Œë¼ìš°ì €ëŠ” Web Speech APIë¥¼ ì§€ì›í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.<br>
                    Chrome, Edge, Safarië¥¼ ì‚¬ìš©í•´ì£¼ì„¸ìš”.<br>
                    <br>
                    <strong>ëŒ€ì•ˆ:</strong><br>
                    1ï¸âƒ£ <strong>ì¶”ì • ëª¨ë“œ</strong> ì‚¬ìš© (ìŒëŸ‰ ê¸°ë°˜ í…ìŠ¤íŠ¸ ìƒì„±)<br>
                    2ï¸âƒ£ ì§ì ‘ í…ìŠ¤íŠ¸ ì…ë ¥
                `;
                return;
            }
            
            statusEl.style.display = 'block';
            statusEl.style.background = '#fff3cd';
            textEl.innerHTML = `
                âš ï¸ <strong>ìŒì„± ì¸ì‹ ì¤€ë¹„</strong><br>
                <br>
                Web Speech APIëŠ” ì˜¤ë””ì˜¤ íŒŒì¼ì„ ì§ì ‘ ì¸ì‹í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.<br>
                <br>
                <strong>ë°©ë²• 1: ìŠ¤í”¼ì»¤ë¡œ ì¬ìƒí•˜ì—¬ ì¸ì‹</strong><br>
                1. ì•„ë˜ "ì¬ìƒ + ì¸ì‹" ë²„íŠ¼ í´ë¦­<br>
                2. ë§ˆì´í¬ ê¶Œí•œ í—ˆìš©<br>
                3. ì˜¤ë””ì˜¤ê°€ ìŠ¤í”¼ì»¤ë¡œ ì¬ìƒë˜ë©° ë§ˆì´í¬ë¡œ ì¸ì‹ë©ë‹ˆë‹¤<br>
                (ì¡°ìš©í•œ í™˜ê²½ì—ì„œ ì‚¬ìš©í•˜ì„¸ìš”!)<br>
                <br>
                <strong>ë°©ë²• 2: ì¶”ì • ëª¨ë“œ ì‚¬ìš©</strong><br>
                "ğŸ” ì¶”ì • ëª¨ë“œ" ë²„íŠ¼ìœ¼ë¡œ ìŒëŸ‰ ê¸°ë°˜ í…ìŠ¤íŠ¸ ìƒì„±<br>
                <br>
                <button onclick="startPlayAndRecognize()" style="padding: 12px 24px; background: #00ff88; border: none; border-radius: 8px; cursor: pointer; font-weight: bold; font-size: 14px; margin-top: 10px;">
                    ğŸ¤ ì¬ìƒ + ì¸ì‹ ì‹œì‘
                </button>
            `;
        }
        
        // ì˜¤ë””ì˜¤ ì¬ìƒí•˜ë©´ì„œ ìŒì„± ì¸ì‹
        async function startPlayAndRecognize() {
            const statusEl = document.getElementById('transcriptionStatus');
            const textEl = document.getElementById('transcriptionText');
            
            const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
            const recognition = new SpeechRecognition();
            
            recognition.continuous = true;  // ì—°ì† ì¸ì‹
            recognition.interimResults = true;  // ì¤‘ê°„ ê²°ê³¼ í‘œì‹œ
            recognition.lang = 'ko-KR';  // í•œêµ­ì–´
            
            let finalTranscript = '';
            let isRecognizing = false;
            
            recognition.onstart = () => {
                isRecognizing = true;
                statusEl.style.background = '#d4edda';
                textEl.innerHTML = `
                    ğŸ¤ <strong>ì¸ì‹ ì¤‘...</strong><br>
                    ì˜¤ë””ì˜¤ë¥¼ ì¬ìƒí•©ë‹ˆë‹¤. ë§ˆì´í¬ê°€ ì†Œë¦¬ë¥¼ ë“£ê³  ìˆìŠµë‹ˆë‹¤.<br>
                    <br>
                    <button onclick="stopPlayAndRecognize()" style="padding: 10px 20px; background: #ff4444; color: white; border: none; border-radius: 8px; cursor: pointer; font-weight: bold;">
                        â¹ï¸ ì¤‘ì§€
                    </button>
                `;
                
                // ì˜¤ë””ì˜¤ ì¬ìƒ ì‹œì‘
                uploadedAudio.currentTime = 0;
                uploadedAudio.play();
            };
            
            recognition.onresult = (event) => {
                let interimTranscript = '';
                
                for (let i = event.resultIndex; i < event.results.length; i++) {
                    const transcript = event.results[i][0].transcript;
                    
                    if (event.results[i].isFinal) {
                        finalTranscript += transcript + ' ';
                    } else {
                        interimTranscript += transcript;
                    }
                }
                
                // ì‹¤ì‹œê°„ ì—…ë°ì´íŠ¸
                document.getElementById('textInputUpload').value = finalTranscript + interimTranscript;
                
                textEl.innerHTML = `
                    ğŸ¤ <strong>ì¸ì‹ ì¤‘...</strong><br>
                    ì¸ì‹ëœ í…ìŠ¤íŠ¸: ${(finalTranscript + interimTranscript).length}ì<br>
                    <br>
                    <div style="background: white; padding: 10px; border-radius: 5px; max-height: 100px; overflow-y: auto; text-align: left; font-size: 13px;">
                        ${finalTranscript}<span style="color: #999;">${interimTranscript}</span>
                    </div>
                    <br>
                    <button onclick="stopPlayAndRecognize()" style="padding: 10px 20px; background: #ff4444; color: white; border: none; border-radius: 8px; cursor: pointer; font-weight: bold;">
                        â¹ï¸ ì¤‘ì§€
                    </button>
                `;
            };
            
            recognition.onerror = (event) => {
                console.error('ì¸ì‹ ì˜¤ë¥˜:', event.error);
                uploadedAudio.pause();
                statusEl.style.background = '#f8d7da';
                textEl.innerHTML = `
                    âŒ <strong>ì¸ì‹ ì‹¤íŒ¨</strong><br>
                    ì˜¤ë¥˜: ${event.error}<br>
                    <br>
                    ë§ˆì´í¬ ê¶Œí•œì„ í™•ì¸í•˜ê±°ë‚˜ "ì¶”ì • ëª¨ë“œ"ë¥¼ ì‚¬ìš©í•˜ì„¸ìš”.
                `;
            };
            
            recognition.onend = () => {
                if (isRecognizing) {
                    uploadedAudio.pause();
                    statusEl.style.background = '#d4edda';
                    textEl.innerHTML = `
                        âœ… <strong>ì¸ì‹ ì™„ë£Œ!</strong><br>
                        ì´ ${finalTranscript.length}ì ì¸ì‹ë¨<br>
                        <br>
                        í…ìŠ¤íŠ¸ë¥¼ í™•ì¸í•˜ê³  ìˆ˜ì •í•˜ì„¸ìš”.
                    `;
                    updateStatus('âœ… ìŒì„± ì¸ì‹ ì™„ë£Œ!', 'idle');
                }
            };
            
            // ì˜¤ë””ì˜¤ ì¢…ë£Œ ì‹œ ì¸ì‹ë„ ì¢…ë£Œ
            uploadedAudio.onended = () => {
                if (isRecognizing) {
                    recognition.stop();
                }
            };
            
            // ì „ì—­ ë³€ìˆ˜ì— ì €ì¥ (ì¤‘ì§€ìš©)
            window.currentRecognition = recognition;
            
            try {
                recognition.start();
            } catch (error) {
                console.error('ì¸ì‹ ì‹œì‘ ì‹¤íŒ¨:', error);
                textEl.innerHTML = `
                    âŒ ì¸ì‹ ì‹œì‘ ì‹¤íŒ¨<br>
                    ${error.message}<br>
                    <br>
                    "ì¶”ì • ëª¨ë“œ"ë¥¼ ëŒ€ì‹  ì‚¬ìš©í•˜ì„¸ìš”.
                `;
            }
        }
        
        function stopPlayAndRecognize() {
            if (window.currentRecognition) {
                window.currentRecognition.stop();
                window.currentRecognition = null;
            }
            if (uploadedAudio) {
                uploadedAudio.pause();
            }
        }

        // ì˜¤ë””ì˜¤ ë¶„ì„ì„ í†µí•œ ë¦½ì‹±í¬ ì¶”ì • ëª¨ë“œ
        async function estimateFromAudio() {
            if (!uploadedAudio) {
                alert('ë¨¼ì € ì˜¤ë””ì˜¤ íŒŒì¼ì„ ì—…ë¡œë“œí•´ì£¼ì„¸ìš”!');
                return;
            }

            const statusEl = document.getElementById('transcriptionStatus');
            const textEl = document.getElementById('transcriptionText');
            
            statusEl.style.display = 'block';
            statusEl.style.background = '#d4edda';
            textEl.innerHTML = 'ğŸ¤– ì˜¤ë””ì˜¤ ë¶„ì„ ì¤‘...';

            try {
                // AudioContextë¥¼ ì‚¬ìš©í•˜ì—¬ ì˜¤ë””ì˜¤ ë¶„ì„
                if (!audioContext) {
                    audioContext = new (window.AudioContext || window.webkitAudioContext)();
                }

                const response = await fetch(uploadedAudio.src);
                const arrayBuffer = await response.arrayBuffer();
                const audioBuffer = await audioContext.decodeAudioData(arrayBuffer);
                
                // ì˜¤ë””ì˜¤ ê¸¸ì´ ê¸°ë°˜ìœ¼ë¡œ ì ì ˆí•œ ë¦½ì‹±í¬ íŒ¨í„´ ìƒì„±
                const duration = audioBuffer.duration;
                const sampleRate = audioBuffer.sampleRate;
                const channelData = audioBuffer.getChannelData(0);
                
                // ìŒëŸ‰ ë¶„ì„í•˜ì—¬ ë§í•˜ëŠ” ë¶€ë¶„ ê°ì§€
                const chunkSize = Math.floor(sampleRate * 0.15); // 150ms ë‹¨ìœ„
                const chunks = [];
                
                for (let i = 0; i < channelData.length; i += chunkSize) {
                    const chunk = channelData.slice(i, i + chunkSize);
                    const rms = Math.sqrt(chunk.reduce((sum, val) => sum + val * val, 0) / chunk.length);
                    chunks.push(rms);
                }
                
                // ìŒëŸ‰ ê¸°ë°˜ ìì—°ìŠ¤ëŸ¬ìš´ ë¦½ì‹±í¬ í…ìŠ¤íŠ¸ ìƒì„±
                let estimatedText = '';
                const maxVolume = Math.max(...chunks);
                const threshold = maxVolume * 0.25; // ìŒëŸ‰ ì„ê³„ê°’
                
                // ë‹¤ì–‘í•œ ìŒì ˆ íŒ¨í„´ (ë” ìì—°ìŠ¤ëŸ½ê²Œ)
                const patterns = {
                    high: ['ì•„', 'ì–´', 'ì˜¤', 'ìš°', 'ì´', 'ì• ', 'ì—'],      // í° ì†Œë¦¬ (ëª¨ìŒ ìœ„ì£¼)
                    medium: ['ê°€', 'ë‚˜', 'ë‹¤', 'ë¼', 'ë§ˆ', 'ë°”', 'ì‚¬',     // ì¤‘ê°„ ì†Œë¦¬ (ì¼ë°˜ ìŒì ˆ)
                             'ì', 'ì¹´', 'íƒ€', 'íŒŒ', 'í•˜'],
                    low: ['ì€', 'ëŠ”', 'ì„', 'ë¥¼', 'ì˜', 'ì—', 'ì™€']         // ì‘ì€ ì†Œë¦¬ (ë¶€ë“œëŸ¬ìš´ ìŒì ˆ)
                };
                
                let prevLevel = 'low';
                let sameCount = 0;
                
                for (let i = 0; i < chunks.length; i++) {
                    const volume = chunks[i];
                    let currentLevel;
                    
                    // ìŒëŸ‰ ë ˆë²¨ ê²°ì •
                    if (volume > threshold * 2) {
                        currentLevel = 'high';
                    } else if (volume > threshold) {
                        currentLevel = 'medium';
                    } else {
                        currentLevel = 'low';
                    }
                    
                    // ê°™ì€ ë ˆë²¨ì´ 3ë²ˆ ì´ìƒ ì—°ì†ë˜ë©´ ë³€í™” ì£¼ê¸°
                    if (currentLevel === prevLevel) {
                        sameCount++;
                        if (sameCount > 2) {
                            // ë ˆë²¨ ê°•ì œ ë³€ê²½
                            const levels = ['high', 'medium', 'low'];
                            currentLevel = levels[(levels.indexOf(currentLevel) + 1) % 3];
                            sameCount = 0;
                        }
                    } else {
                        sameCount = 0;
                    }
                    
                    // ìŒëŸ‰ì´ ë‚®ìœ¼ë©´ ê³µë°± ì¶”ê°€ (ì‰¬ëŠ” êµ¬ê°„)
                    if (volume < threshold * 0.5) {  // ì„ê³„ê°’ì„ 0.3ì—ì„œ 0.5ë¡œ ìƒí–¥ (ë” ìì£¼ ê³µë°±)
                        if (estimatedText.length > 0 && 
                            estimatedText[estimatedText.length - 1] !== ' ') {
                            estimatedText += ' ';
                        }
                    } else {
                        // í•´ë‹¹ ë ˆë²¨ì˜ íŒ¨í„´ì—ì„œ ëœë¤í•˜ê²Œ ì„ íƒ
                        const patternArray = patterns[currentLevel];
                        const syllable = patternArray[Math.floor(Math.random() * patternArray.length)];
                        estimatedText += syllable;
                    }
                    
                    prevLevel = currentLevel;
                }
                
                // ê³µë°± ì •ë¦¬ (ì—°ì†ëœ ê³µë°± ì œê±°)
                estimatedText = estimatedText.replace(/\s+/g, ' ').trim();
                
                // ìì—°ìŠ¤ëŸ¬ìš´ êµ¬ë‘ì  ì¶”ê°€ (ê³µë°± ìˆëŠ” ê³³ì—)
                const words = estimatedText.split(' ');
                let textWithPunctuation = '';
                for (let i = 0; i < words.length; i++) {
                    textWithPunctuation += words[i];
                    
                    // ë§ˆì§€ë§‰ ë‹¨ì–´ê°€ ì•„ë‹ˆë©´
                    if (i < words.length - 1) {
                        // 3-5 ë‹¨ì–´ë§ˆë‹¤ ì‰¼í‘œ, 7-10 ë‹¨ì–´ë§ˆë‹¤ ë§ˆì¹¨í‘œ
                        if ((i + 1) % 7 === 0 || (i + 1) % 10 === 0) {
                            textWithPunctuation += '. ';
                        } else if ((i + 1) % 3 === 0 || (i + 1) % 5 === 0) {
                            textWithPunctuation += ', ';
                        } else {
                            textWithPunctuation += ' ';
                        }
                    }
                }
                estimatedText = textWithPunctuation;
                
                // ë„ˆë¬´ ê¸¸ë©´ ì ì ˆíˆ ì¤„ë°”ê¿ˆ ì¶”ê°€
                if (estimatedText.length > 100) {
                    const sentences = estimatedText.split(/\. /);
                    let formatted = '';
                    
                    for (let i = 0; i < sentences.length; i++) {
                        formatted += sentences[i];
                        if (i < sentences.length - 1) {
                            formatted += '.\n';  // ë§ˆì¹¨í‘œ í›„ ì¤„ë°”ê¿ˆ
                        }
                    }
                    estimatedText = formatted.trim();
                }
                
                // ê²°ê³¼ë¥¼ í…ìŠ¤íŠ¸ í•„ë“œì— ì…ë ¥
                document.getElementById('textInputUpload').value = estimatedText;
                
                textEl.innerHTML = `
                    âœ… <strong>ë¶„ì„ ì™„ë£Œ!</strong><br>
                    ì˜¤ë””ì˜¤ ê¸¸ì´: ${duration.toFixed(2)}ì´ˆ<br>
                    ë¶„ì„ëœ ì²­í¬: ${chunks.length}ê°œ<br>
                    ìƒì„±ëœ í…ìŠ¤íŠ¸: ${estimatedText.length}ê¸€ì<br>
                    ìµœëŒ€ ìŒëŸ‰: ${(maxVolume * 100).toFixed(2)}%<br>
                    <br>
                    ğŸ’¡ ìŒëŸ‰ íŒ¨í„´ì„ ë¶„ì„í•˜ì—¬ ìì—°ìŠ¤ëŸ¬ìš´ í•œê¸€ ìŒì ˆì„ ìƒì„±í–ˆìŠµë‹ˆë‹¤.<br>
                    í•„ìš”ì‹œ ìˆ˜ì •í•˜ì—¬ ì‚¬ìš©í•˜ì„¸ìš”!
                `;
                
                console.log('ì˜¤ë””ì˜¤ ë¶„ì„ ì™„ë£Œ:', {
                    ê¸¸ì´: duration,
                    ì²­í¬ìˆ˜: chunks.length,
                    í…ìŠ¤íŠ¸ê¸¸ì´: estimatedText.length,
                    ìµœëŒ€ìŒëŸ‰: maxVolume,
                    ìƒ˜í”Œ: estimatedText.substring(0, 100)
                });
                
                updateStatus('âœ… ì˜¤ë””ì˜¤ ë¶„ì„ ì™„ë£Œ! í…ìŠ¤íŠ¸ê°€ ìƒì„±ë˜ì—ˆìŠµë‹ˆë‹¤.', 'idle');
                
            } catch (error) {
                console.error('ì˜¤ë””ì˜¤ ë¶„ì„ ì‹¤íŒ¨:', error);
                textEl.innerHTML = `âŒ ì˜¤ë””ì˜¤ ë¶„ì„ ì‹¤íŒ¨: ${error.message}`;
                statusEl.style.background = '#f8d7da';
            }
        }

        function displayPhonemeMapping() {
            const section = document.getElementById('phonemeMappingSection');
            section.style.display = 'block';
            
            displayKoreanMapping();
            displayEnglishMapping();
        }

        function displayKoreanMapping() {
            const mapping = document.getElementById('phonemeMappingKorean');
            
            const labels = {
                'rest': 'ğŸ˜Œ ì‰¬ëŠ” ìƒíƒœ',
                'a': 'ğŸ˜® ã…/ã…‘ (í¬ê²Œ)',
                'ae': 'ğŸ˜ƒ ã…/ã…’ (ì•½ê°„)',
                'eo': 'ğŸ˜¯ ã…“/ã…• (ì¤‘ê°„)',
                'e': 'ğŸ™‚ ã…”/ã…– (ì‘ê²Œ)',
                'o': 'ğŸ˜— ã…—/ã…› (ë‘¥ê·¼)',
                'u': 'ğŸ˜™ ã…œ/ã…  (ìš°)',
                'eu': 'ğŸ˜¬ ã…¡ (ìœ¼)',
                'i': 'ğŸ˜ ã…£ (ì´)',
                'b_p_m': 'ğŸ¤ ã…‚/ã…/ã…',
                'n': 'ğŸ˜› ã„´/ã„¹',
                's': 'ğŸ˜¬ ã……/ã…†',
                't_d': 'ğŸ˜‘ ã…Œ/ã„·',
                'g_k': 'ğŸ˜® ã„±/ã…‹',
                'j': 'ğŸ˜ ã…ˆ/ã…Š',
                'h': 'ğŸ˜² ã…',
                'ng': 'ğŸ˜® ã…‡'
            };
            
            mapping.innerHTML = '<h4>ğŸ‡°ğŸ‡· í•œêµ­ì–´ ë°œìŒ ë§¤í•‘:</h4>';
            
            for (let [key, label] of Object.entries(labels)) {
                const item = document.createElement('div');
                item.className = 'phoneme-item';
                
                const labelEl = document.createElement('label');
                labelEl.textContent = label;
                
                const select = document.createElement('select');
                for (let i = 0; i < mouthFrames.length; i++) {
                    const option = document.createElement('option');
                    option.value = i;
                    option.textContent = `ì…ëª¨ì–‘ ${i}`;
                    if (i === phonemeMapKorean[key]) {
                        option.selected = true;
                    }
                    select.appendChild(option);
                }
                select.onchange = (e) => {
                    phonemeMapKorean[key] = parseInt(e.target.value);
                };
                
                item.appendChild(labelEl);
                item.appendChild(select);
                mapping.appendChild(item);
            }
        }

        function displayEnglishMapping() {
            const mapping = document.getElementById('phonemeMappingEnglish');
            
            const labels = {
                'rest': 'ğŸ˜Œ Silence',
                'AA': 'ğŸ˜® AA (f a ther)',
                'AE': 'ğŸ˜ƒ AE (c a t)',
                'AH': 'ğŸ˜¯ AH (b u t)',
                'AO': 'ğŸ˜— AO (d og)',
                'EH': 'ğŸ™‚ EH (b e d)',
                'IH': 'ğŸ˜ IH (s i t)',
                'IY': 'ğŸ˜ IY (s ee )',
                'OW': 'ğŸ˜— OW (b oa t)',
                'UH': 'ğŸ˜™ UH (b oo k)',
                'UW': 'ğŸ˜™ UW (f oo d)',
                'B': 'ğŸ¤ B/P/M',
                'F': 'ğŸ˜¬ F/V',
                'S': 'ğŸ˜¬ S/Z',
                'T': 'ğŸ˜‘ T/D',
                'N': 'ğŸ˜› N/L',
                'R': 'ğŸ˜¯ R',
                'K': 'ğŸ˜® K/G',
                'SH': 'ğŸ˜ SH/CH',
                'H': 'ğŸ˜² H',
                'W': 'ğŸ˜™ W',
                'Y': 'ğŸ˜ Y'
            };
            
            mapping.innerHTML = '<h4>ğŸ‡ºğŸ‡¸ ì˜ì–´ ë°œìŒ ë§¤í•‘:</h4>';
            
            for (let [key, label] of Object.entries(labels)) {
                const item = document.createElement('div');
                item.className = 'phoneme-item';
                
                const labelEl = document.createElement('label');
                labelEl.textContent = label;
                
                const select = document.createElement('select');
                for (let i = 0; i < mouthFrames.length; i++) {
                    const option = document.createElement('option');
                    option.value = i;
                    option.textContent = `Mouth ${i}`;
                    if (i === phonemeMapEnglish[key]) {
                        option.selected = true;
                    }
                    select.appendChild(option);
                }
                select.onchange = (e) => {
                    phonemeMapEnglish[key] = parseInt(e.target.value);
                };
                
                item.appendChild(labelEl);
                item.appendChild(select);
                mapping.appendChild(item);
            }
        }

        function drawCurrentMouth() {
            if (mouthFrames.length === 0) {
                const bgColor = document.getElementById('bgColor').value;
                ctx.fillStyle = bgColor;
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                return;
            }
            
            const bgColor = document.getElementById('bgColor').value;
            ctx.fillStyle = bgColor;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            const frameData = mouthFrames[currentMouthIndex];
            const frame = frameData.canvas;
            const bounds = frameData.bounds;
            const scale = mouthScale;
            
            const scaledWidth = bounds.width * scale;
            const scaledHeight = bounds.height * scale;
            
            const destX = (canvas.width / 2) - (bounds.centerX * scale);
            const destY = (canvas.height / 2) - (bounds.centerY * scale);
            
            ctx.drawImage(
                frame,
                destX,
                destY,
                frame.width * scale,
                frame.height * scale
            );
        }

        function updateMouthSize() {
            const slider = document.getElementById('mouthSize');
            mouthScale = parseFloat(slider.value);
            document.getElementById('sizeValue').textContent = mouthScale.toFixed(1);
            drawCurrentMouth();
        }

        function updateSilenceThreshold() {
            const slider = document.getElementById('silenceThresholdSlider');
            silenceThreshold = parseInt(slider.value);
            document.getElementById('silenceValue').textContent = silenceThreshold;
            console.log('ë¬´ìŒ ê°ì§€ ë¯¼ê°ë„:', silenceThreshold);
        }

        function setPresetColor(color) {
            document.getElementById('bgColor').value = color;
            drawCurrentMouth();
        }

        function setSpeed(speed) {
            speechRate = speed;
            document.querySelectorAll('.speed-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            event.target.classList.add('active');
        }

        document.getElementById('bgColor').addEventListener('input', drawCurrentMouth);

        function loadVoices() {
            voices = synth.getVoices();
            const voiceSelect = document.getElementById('voiceSelect');
            voiceSelect.innerHTML = '';
            
            const koreanVoices = voices.filter(v => 
                v.lang.toLowerCase().includes('ko') || 
                v.name.toLowerCase().includes('korean') ||
                v.name.toLowerCase().includes('í•œêµ­')
            );
            const englishVoices = voices.filter(v =>
                v.lang.toLowerCase().includes('en') ||
                v.name.toLowerCase().includes('english')
            );
            const otherVoices = voices.filter(v => 
                !v.lang.toLowerCase().includes('ko') && 
                !v.name.toLowerCase().includes('korean') &&
                !v.name.toLowerCase().includes('í•œêµ­') &&
                !v.lang.toLowerCase().includes('en') &&
                !v.name.toLowerCase().includes('english')
            );
            
            if (koreanVoices.length > 0) {
                const group = document.createElement('optgroup');
                group.label = 'ğŸ‡°ğŸ‡· í•œêµ­ì–´ ìŒì„±';
                koreanVoices.forEach(voice => {
                    const option = document.createElement('option');
                    option.value = voices.indexOf(voice);
                    option.textContent = `${voice.name} (${voice.lang})`;
                    if (voice.default || voice.localService) {
                        option.textContent += ' â­';
                    }
                    group.appendChild(option);
                });
                voiceSelect.appendChild(group);
                voiceSelect.value = voices.indexOf(koreanVoices[0]);
            }
            
            if (englishVoices.length > 0) {
                const group = document.createElement('optgroup');
                group.label = 'ğŸ‡ºğŸ‡¸ ì˜ì–´ ìŒì„±';
                englishVoices.forEach(voice => {
                    const option = document.createElement('option');
                    option.value = voices.indexOf(voice);
                    option.textContent = `${voice.name} (${voice.lang})`;
                    if (voice.default || voice.localService) {
                        option.textContent += ' â­';
                    }
                    group.appendChild(option);
                });
                voiceSelect.appendChild(group);
            }
            
            if (otherVoices.length > 0) {
                const group = document.createElement('optgroup');
                group.label = 'ğŸŒ ê¸°íƒ€ ì–¸ì–´';
                otherVoices.slice(0, 10).forEach(voice => {
                    const option = document.createElement('option');
                    option.value = voices.indexOf(voice);
                    option.textContent = `${voice.name} (${voice.lang})`;
                    group.appendChild(option);
                });
                voiceSelect.appendChild(group);
            }
            
            console.log('ì‚¬ìš© ê°€ëŠ¥í•œ ìŒì„±:', voices.length + 'ê°œ');
            console.log('í•œêµ­ì–´ ìŒì„±:', koreanVoices.length + 'ê°œ');
            console.log('ì˜ì–´ ìŒì„±:', englishVoices.length + 'ê°œ');
        }

        if (synth.onvoiceschanged !== undefined) {
            synth.onvoiceschanged = loadVoices;
        }
        
        loadVoices();
        setTimeout(() => { if (voices.length === 0) loadVoices(); }, 1000);
        setTimeout(() => { if (voices.length === 0) { voices = synth.getVoices(); loadVoices(); } }, 3000);

        async function toggleRecording() {
            if (!isRecording) {
                await startRecording();
            } else {
                stopRecording();
            }
        }

        async function startRecording() {
            if (mouthFrames.length === 0) {
                alert('ë¨¼ì € ì… ëª¨ì–‘ ì´ë¯¸ì§€ë¥¼ ì—…ë¡œë“œí•´ì£¼ì„¸ìš”!');
                return;
            }
            
            try {
                const stream = canvas.captureStream(30);
                mediaRecorder = new MediaRecorder(stream, {
                    mimeType: 'video/webm;codecs=vp9',
                    videoBitsPerSecond: 8000000
                });
                
                recordedChunks = [];
                
                mediaRecorder.ondataavailable = (event) => {
                    if (event.data.size > 0) {
                        recordedChunks.push(event.data);
                    }
                };
                
                mediaRecorder.onstop = () => {
                    const blob = new Blob(recordedChunks, { type: 'video/webm' });
                    const url = URL.createObjectURL(blob);
                    
                    const downloadBtn = document.getElementById('downloadBtn');
                    downloadBtn.style.display = 'block';
                    downloadBtn.disabled = false;
                    downloadBtn.onclick = () => {
                        const a = document.createElement('a');
                        a.href = url;
                        a.download = `lipsync_${Date.now()}.webm`;
                        a.click();
                    };
                    
                    updateStatus('âœ… ë…¹í™” ì™„ë£Œ! ì˜ìƒì„ ë‹¤ìš´ë¡œë“œí•˜ì„¸ìš”.', 'idle');
                };
                
                mediaRecorder.start();
                isRecording = true;
                
                const recordBtn = document.getElementById('recordBtn');
                recordBtn.textContent = 'â¹ï¸ ë…¹í™” ì¤‘ì§€';
                recordBtn.classList.add('recording');
                
                updateStatus('ğŸ”´ ë…¹í™” ì¤‘...', 'recording');
                
            } catch (error) {
                console.error('ë…¹í™” ì‹¤íŒ¨:', error);
                alert('ë…¹í™”ë¥¼ ì‹œì‘í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.');
            }
        }

        function stopRecording() {
            if (mediaRecorder && isRecording) {
                mediaRecorder.stop();
                isRecording = false;
                
                const recordBtn = document.getElementById('recordBtn');
                recordBtn.textContent = 'âºï¸ ë…¹í™” ì‹œì‘';
                recordBtn.classList.remove('recording');
            }
        }

        async function speak() {
            if (mouthFrames.length === 0) {
                alert('ë¨¼ì € ì… ëª¨ì–‘ ì´ë¯¸ì§€ë¥¼ ì—…ë¡œë“œí•´ì£¼ì„¸ìš”!');
                return;
            }
            
            stop();

            if (audioMode === 'upload') {
                // ì—…ë¡œë“œëœ ì˜¤ë””ì˜¤ ì¬ìƒ
                if (!uploadedAudio) {
                    alert('ë¨¼ì € ì˜¤ë””ì˜¤ íŒŒì¼ì„ ì—…ë¡œë“œí•´ì£¼ì„¸ìš”!');
                    return;
                }
                
                const text = document.getElementById('textInputUpload').value.trim();
                
                // í…ìŠ¤íŠ¸ê°€ ì—†ì–´ë„ ì¬ìƒ ê°€ëŠ¥ (ìë™ ë¦½ì‹±í¬ ëª¨ë“œ)
                if (!text) {
                    const confirmPlay = confirm('í…ìŠ¤íŠ¸ê°€ ì—†ìŠµë‹ˆë‹¤.\n\nìë™ ë¦½ì‹±í¬ ëª¨ë“œë¡œ ì¬ìƒí•˜ì‹œê² ìŠµë‹ˆê¹Œ?\n\n(ìŒëŸ‰ íŒ¨í„´ ê¸°ë°˜ìœ¼ë¡œ ì… ëª¨ì–‘ì´ ìë™ìœ¼ë¡œ ë³€ê²½ë©ë‹ˆë‹¤)');
                    if (!confirmPlay) {
                        return;
                    }
                }
                
                playUploadedAudio(text);
            } else {
                // TTS ìŒì„± ì¬ìƒ
                const text = document.getElementById('textInput').value.trim();
                
                if (!text) {
                    alert('í…ìŠ¤íŠ¸ë¥¼ ì…ë ¥í•´ì£¼ì„¸ìš”!');
                    return;
                }

                if (ttsEngine === 'google') {
                    // Google Cloud TTS ì‚¬ìš©
                    const audioUrl = await synthesizeWithGoogleTTS(text);
                    if (!audioUrl) {
                        return; // ì˜¤ë¥˜ ë°œìƒ ì‹œ ì¤‘ë‹¨
                    }
                    
                    // ìƒì„±ëœ ì˜¤ë””ì˜¤ë¥¼ Audio ê°ì²´ë¡œ ì¬ìƒ
                    const audio = new Audio(audioUrl);
                    
                    audio.onloadedmetadata = () => {
                        const duration = audio.duration;
                        console.log('Google TTS ì˜¤ë””ì˜¤ ê¸¸ì´:', duration);
                        
                        isSpeaking = true;
                        updateStatus('ğŸ—£ï¸ Google TTS ì¬ìƒ ì¤‘...', 'speaking');
                        document.getElementById('speakBtn').disabled = true;
                        document.getElementById('stopBtn').disabled = false;
                        
                        // ì˜¤ë””ì˜¤ ì»¨í…ìŠ¤íŠ¸ ì„¤ì • (ë¬´ìŒ ê°ì§€ìš©)
                        setupAudioContext(audio);
                        
                        // í…ìŠ¤íŠ¸ ê¸°ë°˜ ë¦½ì‹±í¬ + ë¬´ìŒ ê°ì§€
                        animateLipSyncWithAudioAndSilence(text, duration);
                    };
                    
                    audio.onended = () => {
                        console.log('Google TTS ì¬ìƒ ì™„ë£Œ');
                        isSpeaking = false;
                        stopAudioAnalysis();
                        setTimeout(() => {
                            stop();
                            if (isRecording) {
                                setTimeout(() => stopRecording(), 500);
                            }
                        }, 300);
                    };
                    
                    audio.onerror = (e) => {
                        console.error('ì˜¤ë””ì˜¤ ì¬ìƒ ì˜¤ë¥˜:', e);
                        stop();
                        alert('ì˜¤ë””ì˜¤ ì¬ìƒ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.');
                    };
                    
                    audio.play().catch(err => {
                        console.error('ì¬ìƒ ì‹¤íŒ¨:', err);
                        alert('ì˜¤ë””ì˜¤ ì¬ìƒ ì‹¤íŒ¨: ' + err.message);
                        stop();
                    });
                    
                } else {
                    // ë¸Œë¼ìš°ì € ë‚´ì¥ TTS ì‚¬ìš©
                    if (voices.length === 0) {
                        voices = synth.getVoices();
                    }

                    utterance = new SpeechSynthesisUtterance(text);
                    
                    const detectedLang = detectLanguage(text);
                    console.log('ê°ì§€ëœ ì–¸ì–´:', detectedLang);
                    
                    const selectedVoiceIndex = document.getElementById('voiceSelect').value;
                    if (selectedVoiceIndex !== '' && voices[selectedVoiceIndex]) {
                        utterance.voice = voices[selectedVoiceIndex];
                        console.log('ì‚¬ìš© ì¤‘ì¸ ìŒì„±:', voices[selectedVoiceIndex].name);
                    } else {
                        if (detectedLang === 'korean') {
                            const koreanVoice = voices.find(v => 
                                v.lang.toLowerCase().includes('ko') || 
                                v.name.toLowerCase().includes('korean')
                            );
                            if (koreanVoice) {
                                utterance.voice = koreanVoice;
                                utterance.lang = 'ko-KR';
                            }
                        } else {
                            const englishVoice = voices.find(v =>
                                v.lang.toLowerCase().includes('en')
                            );
                            if (englishVoice) {
                                utterance.voice = englishVoice;
                                utterance.lang = 'en-US';
                            }
                        }
                    }
                    
                    utterance.rate = speechRate;
                    utterance.pitch = 1.0;
                    utterance.volume = 1.0;

                    utterance.onstart = () => {
                        isSpeaking = true;
                        updateStatus('ğŸ—£ï¸ ë§í•˜ëŠ” ì¤‘...', 'speaking');
                        document.getElementById('speakBtn').disabled = true;
                        document.getElementById('stopBtn').disabled = false;
                        
                        console.log('TTS ì‹œì‘:', {
                            text: text.substring(0, 30) + '...',
                            voice: utterance.voice ? utterance.voice.name : 'ê¸°ë³¸',
                            lang: utterance.lang,
                            rate: utterance.rate,
                            detected: detectedLang
                        });
                        
                        animateLipSync(text);
                    };

                    utterance.onend = () => {
                        console.log('TTS ì™„ë£Œ');
                        isSpeaking = false;
                        setTimeout(() => {
                            stop();
                            if (isRecording) {
                                setTimeout(() => stopRecording(), 500);
                            }
                        }, 300);
                    };

                    utterance.onerror = (event) => {
                        console.error('TTS ì˜¤ë¥˜:', event);
                        stop();
                        alert('ìŒì„± ì¬ìƒ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.');
                    };

                    try {
                        synth.speak(utterance);
                        console.log('synth.speak() í˜¸ì¶œ ì™„ë£Œ');
                    } catch (e) {
                        console.error('synth.speak() ì˜¤ë¥˜:', e);
                        alert('ìŒì„± ì¬ìƒì„ ì‹œì‘í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤: ' + e.message);
                        stop();
                    }
                }
            }
        }

        function playUploadedAudio(text) {
            isSpeaking = true;
            updateStatus('ğŸµ ì˜¤ë””ì˜¤ ì¬ìƒ ì¤‘...', 'speaking');
            document.getElementById('speakBtn').disabled = true;
            document.getElementById('stopBtn').disabled = false;
            
            // ì˜¤ë””ì˜¤ ì¬ìƒ
            uploadedAudio.currentTime = 0;
            uploadedAudio.playbackRate = speechRate;
            
            // ì˜¤ë””ì˜¤ ì»¨í…ìŠ¤íŠ¸ ì´ˆê¸°í™”
            if (!audioContext) {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
            }
            
            if (audioContext.state === 'suspended') {
                audioContext.resume();
            }
            
            // ì˜¤ë””ì˜¤ ì†ŒìŠ¤ì™€ ë¶„ì„ê¸° ì„¤ì • (í•œ ë²ˆë§Œ ìƒì„±)
            if (!audioSource) {
                try {
                    audioSource = audioContext.createMediaElementSource(uploadedAudio);
                    analyser = audioContext.createAnalyser();
                    analyser.fftSize = 256;
                    analyser.smoothingTimeConstant = 0.8;
                    
                    audioSource.connect(analyser);
                    analyser.connect(audioContext.destination);
                    
                    console.log('âœ… ì˜¤ë””ì˜¤ ë¶„ì„ê¸° ì—°ê²° ì™„ë£Œ (ì¬ìƒ ì¤‘ì¸ ì˜¤ë””ì˜¤ ë¶„ì„)');
                } catch (e) {
                    console.error('ì˜¤ë””ì˜¤ ì†ŒìŠ¤ ìƒì„± ì˜¤ë¥˜:', e);
                    // ì´ë¯¸ ìƒì„±ëœ ê²½ìš° ë¬´ì‹œí•˜ê³  ê³„ì† ì§„í–‰
                }
            }
            
            const playPromise = uploadedAudio.play();
            
            if (playPromise !== undefined) {
                playPromise.then(() => {
                    console.log('ì˜¤ë””ì˜¤ ì¬ìƒ ì‹œì‘');
                    
                    // í…ìŠ¤íŠ¸ê°€ ìˆìœ¼ë©´ í…ìŠ¤íŠ¸ ê¸°ë°˜ ë¦½ì‹±í¬ + ì‹¤ì‹œê°„ ìŒëŸ‰ ê°ì§€
                    if (text && text.trim()) {
                        animateLipSyncWithAudioAndSilence(text, uploadedAudio.duration);
                    } else {
                        // í…ìŠ¤íŠ¸ ì—†ìœ¼ë©´ ìŒëŸ‰ë§Œìœ¼ë¡œ ë¦½ì‹±í¬
                        animateWithAudioAnalysis();
                    }
                    
                }).catch(error => {
                    console.error('ì˜¤ë””ì˜¤ ì¬ìƒ ì‹¤íŒ¨:', error);
                    alert('ì˜¤ë””ì˜¤ë¥¼ ì¬ìƒí•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.');
                    stop();
                });
            }
            
            // ì˜¤ë””ì˜¤ ì¢…ë£Œ ì´ë²¤íŠ¸
            uploadedAudio.onended = () => {
                console.log('ì˜¤ë””ì˜¤ ì¬ìƒ ì™„ë£Œ');
                stopAudioAnalysis();
                isSpeaking = false;
                setTimeout(() => {
                    stop();
                    if (isRecording) {
                        setTimeout(() => stopRecording(), 500);
                    }
                }, 300);
            };
            
            uploadedAudio.onerror = (e) => {
                console.error('ì˜¤ë””ì˜¤ ì¬ìƒ ì˜¤ë¥˜:', e);
                stopAudioAnalysis();
                stop();
                alert('ì˜¤ë””ì˜¤ ì¬ìƒ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.');
            };
        }

        // ì‹¤ì‹œê°„ ì˜¤ë””ì˜¤ ë¶„ì„ìœ¼ë¡œ ë¦½ì‹±í¬ (í…ìŠ¤íŠ¸ ì—†ì„ ë•Œ)
        function animateWithAudioAnalysis() {
            const bufferLength = analyser.frequencyBinCount;
            const dataArray = new Uint8Array(bufferLength);
            
            function analyzeFrame() {
                if (!isSpeaking || !analyser) return;
                
                analyser.getByteFrequencyData(dataArray);
                
                // í‰ê·  ìŒëŸ‰ ê³„ì‚°
                let sum = 0;
                for (let i = 0; i < bufferLength; i++) {
                    sum += dataArray[i];
                }
                const average = sum / bufferLength;
                
                // ìŒëŸ‰ì— ë”°ë¼ ì… ëª¨ì–‘ ê²°ì •
                if (average > silenceThreshold) {
                    // ì†Œë¦¬ ìˆìŒ - ëœë¤í•˜ê²Œ ëª¨ìŒ ì… ëª¨ì–‘
                    const vowelIndices = [4, 5, 6, 7, 8, 9, 10, 11]; // ëª¨ìŒ ì¸ë±ìŠ¤ë“¤
                    const randomIndex = vowelIndices[Math.floor(Math.random() * vowelIndices.length)];
                    currentMouthIndex = randomIndex;
                    lastSoundTime = Date.now();
                } else {
                    // ë¬´ìŒ - ì… ë‹«ê¸°
                    if (Date.now() - lastSoundTime > silenceDelay) {
                        currentMouthIndex = phonemeMapKorean['rest'];
                    }
                }
                
                drawCurrentMouth();
                
                audioMonitorInterval = requestAnimationFrame(analyzeFrame);
            }
            
            console.log('ì‹¤ì‹œê°„ ì˜¤ë””ì˜¤ ë¶„ì„ ì‹œì‘ (ë¬´ìŒ ê°ì§€ í™œì„±í™”)');
            analyzeFrame();
        }

        // í…ìŠ¤íŠ¸ ê¸°ë°˜ ë¦½ì‹±í¬ + ì‹¤ì‹œê°„ ë¬´ìŒ ê°ì§€ ê²°í•©
        function animateLipSyncWithAudioAndSilence(text, audioDuration) {
            const phonemeSequence = textToPhonemes(text);
            
            // ì˜¤ë””ì˜¤ ê¸¸ì´ì— ë§ì¶° ê° ë°œìŒì˜ duration ì¡°ì •
            const totalTextDuration = phonemeSequence.reduce((sum, p) => sum + p.duration, 0);
            const scaleFactor = (audioDuration * 1000) / totalTextDuration;
            
            phonemeSequence.forEach(p => {
                p.duration *= scaleFactor;
            });
            
            // ì—°ì†ëœ ê°™ì€ ë°œìŒ í•©ì¹˜ê¸°
            const optimizedSequence = [];
            for (let i = 0; i < phonemeSequence.length; i++) {
                const current = phonemeSequence[i];
                let combinedDuration = current.duration;
                let j = i + 1;
                
                while (j < phonemeSequence.length &&
                       phonemeSequence[j].phoneme === current.phoneme &&
                       phonemeSequence[j].map === current.map) {
                    combinedDuration += phonemeSequence[j].duration;
                    j++;
                }
                
                optimizedSequence.push({
                    phoneme: current.phoneme,
                    duration: combinedDuration,
                    map: current.map
                });
                
                i = j - 1;
            }
            
            console.log('ë¦½ì‹±í¬ ìµœì í™” (ë¬´ìŒ ê°ì§€ í¬í•¨):', {
                ì›ë³¸ë°œìŒìˆ˜: phonemeSequence.length,
                ìµœì í™”í›„: optimizedSequence.length,
                ë¬´ìŒê°ì§€: 'í™œì„±í™”'
            });
            
            let index = 0;
            const bufferLength = analyser.frequencyBinCount;
            const dataArray = new Uint8Array(bufferLength);
            
            function nextPhoneme() {
                if (!isSpeaking) {
                    currentMouthIndex = phonemeMapKorean['rest'];
                    drawCurrentMouth();
                    return;
                }
                
                // ì‹¤ì‹œê°„ ìŒëŸ‰ ë¶„ì„
                if (analyser) {
                    analyser.getByteFrequencyData(dataArray);
                    let sum = 0;
                    for (let i = 0; i < bufferLength; i++) {
                        sum += dataArray[i];
                    }
                    const average = sum / bufferLength;
                    
                    // ë¬´ìŒ ê°ì§€ - ìŒëŸ‰ì´ ë‚®ìœ¼ë©´ ì… ë‹«ê¸°
                    if (average < silenceThreshold) {
                        if (Date.now() - lastSoundTime > silenceDelay) {
                            currentMouthIndex = phonemeMapKorean['rest'];
                            drawCurrentMouth();
                            animationInterval = setTimeout(nextPhoneme, 50);
                            return;
                        }
                    } else {
                        lastSoundTime = Date.now();
                    }
                }
                
                // í…ìŠ¤íŠ¸ ê¸°ë°˜ ë¦½ì‹±í¬
                if (index < optimizedSequence.length) {
                    const { phoneme, duration, map } = optimizedSequence[index];
                    currentMouthIndex = map[phoneme] || map['rest'];
                    drawCurrentMouth();
                    index++;
                    animationInterval = setTimeout(nextPhoneme, duration);
                } else {
                    currentMouthIndex = phonemeMapKorean['rest'];
                    drawCurrentMouth();
                }
            }
            
            console.log('ë¦½ì‹±í¬ ì‹œì‘ (í…ìŠ¤íŠ¸ + ë¬´ìŒê°ì§€)');
            nextPhoneme();
        }

        function stopAudioAnalysis() {
            if (audioMonitorInterval) {
                cancelAnimationFrame(audioMonitorInterval);
                audioMonitorInterval = null;
            }
            analyser = null;
        }

        // í…ìŠ¤íŠ¸ ì—†ì´ ìë™ìœ¼ë¡œ ë¦½ì‹±í¬ (ì… ë‹«íŒ ìƒíƒœ ìœ ì§€)
        function animateAutoLipSync(audioDuration) {
            console.log('í…ìŠ¤íŠ¸ ì—†ìŒ - ì… ë‹«íŒ ìƒíƒœ ìœ ì§€');
            
            // ì…ì„ ë‹«íŒ ìƒíƒœë¡œ ìœ ì§€
            currentMouthIndex = phonemeMapKorean['rest'];
            drawCurrentMouth();
            
            console.log('ì˜¤ë””ì˜¤ë§Œ ì¬ìƒ ì¤‘:', {
                ì˜¤ë””ì˜¤ê¸¸ì´: audioDuration.toFixed(2) + 'ì´ˆ',
                ë¦½ì‹±í¬: 'ë¹„í™œì„± (í…ìŠ¤íŠ¸ ì…ë ¥ ì‹œ í™œì„±í™”)'
            });
        }

        function animateLipSyncWithAudio(text, audioDuration) {
            const phonemeSequence = textToPhonemes(text);
            
            // ì˜¤ë””ì˜¤ ê¸¸ì´ì— ë§ì¶° ê° ë°œìŒì˜ duration ì¡°ì •
            const totalTextDuration = phonemeSequence.reduce((sum, p) => sum + p.duration, 0);
            const scaleFactor = (audioDuration * 1000) / totalTextDuration; // ë°€ë¦¬ì´ˆë¡œ ë³€í™˜
            
            phonemeSequence.forEach(p => {
                p.duration *= scaleFactor;
            });
            
            // ì—°ì†ëœ ê°™ì€ ë°œìŒì„ ë¯¸ë¦¬ í•©ì¹˜ê¸° (ìµœì í™”)
            const optimizedSequence = [];
            for (let i = 0; i < phonemeSequence.length; i++) {
                const current = phonemeSequence[i];
                
                // ê°™ì€ ë°œìŒì´ ì—°ì†ë˜ëŠ”ì§€ í™•ì¸
                let combinedDuration = current.duration;
                let j = i + 1;
                
                while (j < phonemeSequence.length &&
                       phonemeSequence[j].phoneme === current.phoneme &&
                       phonemeSequence[j].map === current.map) {
                    combinedDuration += phonemeSequence[j].duration;
                    j++;
                }
                
                // í•©ì³ì§„ ë°œìŒ ì¶”ê°€
                optimizedSequence.push({
                    phoneme: current.phoneme,
                    duration: combinedDuration,
                    map: current.map
                });
                
                // ë‹¤ìŒ ì¸ë±ìŠ¤ë¡œ ì í”„
                i = j - 1;
            }
            
            console.log('ë¦½ì‹±í¬ ìµœì í™”:', {
                ì›ë³¸ë°œìŒìˆ˜: phonemeSequence.length,
                ìµœì í™”í›„: optimizedSequence.length,
                ê°ì†Œìœ¨: ((1 - optimizedSequence.length / phonemeSequence.length) * 100).toFixed(1) + '%'
            });
            
            let index = 0;
            
            function nextPhoneme() {
                if (!isSpeaking || index >= optimizedSequence.length) {
                    currentMouthIndex = phonemeMapKorean['rest'];
                    drawCurrentMouth();
                    return;
                }
                
                const { phoneme, duration, map } = optimizedSequence[index];
                currentMouthIndex = map[phoneme] || map['rest'];
                drawCurrentMouth();
                
                index++;
                animationInterval = setTimeout(nextPhoneme, duration);
            }
            
            console.log('ë¦½ì‹±í¬ ì‹œì‘ (ì˜¤ë””ì˜¤ ë™ê¸°í™”):', {
                ì˜¤ë””ì˜¤ê¸¸ì´: audioDuration.toFixed(2) + 'ì´ˆ',
                ë°œìŒê°œìˆ˜: optimizedSequence.length,
                ìŠ¤ì¼€ì¼: scaleFactor.toFixed(2)
            });
            
            nextPhoneme();
        }

        function stop() {
            synth.cancel();
            
            // ì—…ë¡œë“œëœ ì˜¤ë””ì˜¤ ì •ì§€
            if (uploadedAudio) {
                uploadedAudio.pause();
                uploadedAudio.currentTime = 0;
            }
            
            // ì˜¤ë””ì˜¤ ë¶„ì„ ì¤‘ì§€
            stopAudioAnalysis();
            
            isSpeaking = false;
            
            if (animationInterval) {
                clearTimeout(animationInterval);
                animationInterval = null;
            }
            
            currentMouthIndex = phonemeMapKorean['rest'];
            drawCurrentMouth();
            
            updateStatus('ëŒ€ê¸° ì¤‘...', 'idle');
            document.getElementById('speakBtn').disabled = false;
            document.getElementById('stopBtn').disabled = true;
        }

        function updateStatus(message, className) {
            const status = document.getElementById('status');
            status.textContent = message;
            status.className = `status ${className}`;
        }

        document.getElementById('textInput').addEventListener('keydown', (e) => {
            if (e.key === 'Enter' && e.ctrlKey) {
                e.preventDefault();
                speak();
            }
        });

        ctx.fillStyle = '#00ff00';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
    </script>
</body>
</html>
